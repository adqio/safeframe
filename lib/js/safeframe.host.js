(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var sf;

  sf = require("./host/host");

  (function(window, sf) {
    return window["$sf"] = sf;
  })(window, sf);

  module.exports = sf;

}).call(this);

},{"./host/host":3}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var sf;

  sf = require('../shared/base');

  module.exports = (function(window, sf) {
    var AUTO_BOOT_MAX_RETRIES, SF_DATATAG_CLASS, SF_POSELEM_WRAPPER_CLASS, SF_TAG_TYPE, boot, boot_retries, d, doing_auto_boot, dom, has_booted, inline_tags_processed, lang, lib, win, _attr, _auto_boot, _clean_up_booted_tags, _create_pos_markup, _cstr, _elt, _guid, _log, _par, _purge, _ready, _tags;
    win = window != null ? window : this;
    _log = function(msg, is_err) {
      var err_tag, head_el, lib;
      try {
        lib = sf.lib;
        if (lib && lib.logger && win === top) {
          if (is_err) {
            lib.logger.error(msg);
          } else {
            lib.logger.log(msg);
          }
        } else {
          head_el = d.getElementsByTagName("head")[0];
          err_tag = d.createElement("script");
          err_tag.type = "text/plain";
          err_tag.text = "<!-- SafeFrame " + (is_err ? "error" : "log") + ": " + (msg || "unknown") + " -->";
          head_el.appendChild(head_el, err_tag);
        }
      } catch (_error) {}
    };

    /*
    Create the HTML markup for a position if a src property was used
    
    @name $sf.host-_create_pos_markup
    @function
    @private
    @static
    @return {String}
     */
    _create_pos_markup = function(src) {
      return _cstr(["<scr", "ipt type='text/javascript', src='", src, "'></scr", "ipt>"]);
    };
    _auto_boot = function() {
      var config, do_auto, doing_auto_boot, e, head, host_file, scr_tag, sf_host;
      do_auto = true;
      config = void 0;
      sf_host = void 0;
      host_file = void 0;
      head = void 0;
      scr_tag = void 0;
      if (has_booted) {
        return;
      }
      sf_host = sf && sf.host;
      if (win === top) {
        if (sf_host && !sf_host.boot) {
          sf_host.boot = boot;
        }
        try {
          config = sf_host && sf_host.Config();
        } catch (_error) {
          e = _error;
          config = null;
        }
        if (!config) {
          try {
            config = sf_host && sf_host.conf;
          } catch (_error) {
            e = _error;
            config = null;
          }
        }
        if (config) {
          if (("auto" in config) && config.auto === false) {
            do_auto = false;
          }
          if (!sf_host.render || !sf_host.Config) {
            host_file = config.hostFile;
            if (host_file) {
              head = _tags("head")[0];
              scr_tag = dom.make("script");
              scr_tag.id = "sf_host_lib";
              scr_tag.type = "text/javascript";
              scr_tag.className = "sf_lib";
              scr_tag.src = host_file;
              if (win.ActiveXObject) {
                scr_tag.onreadystatechange = function() {
                  var doing_auto_boot, rs;
                  rs = scr_tag.readyState;
                  if (rs === "loaded" || rs === "complete") {
                    doing_auto_boot = false;
                    if (do_auto) {
                      boot();
                    }
                    scr_tag.onreadystatechange = null;
                    scr_tag = head = sf_host = config = null;
                  }
                };
              } else {
                scr_tag.onload = function() {
                  var doing_auto_boot;
                  doing_auto_boot = false;
                  if (do_auto) {
                    boot();
                  }
                  scr_tag.onload = null;
                  scr_tag = head = sf_host = config = null;
                };
              }
              doing_auto_boot = true;
              head.appendChild(scr_tag);
              return;
            }
          }
        }
        if (do_auto) {
          if (config) {
            doing_auto_boot = true;
            boot();
            doing_auto_boot = false;
          } else {
            if (boot_retries++ <= AUTO_BOOT_MAX_RETRIES) {
              setTimeout(_auto_boot, 50);
            }
          }
        }
      } else {
        boot();
      }
    };

    /*
    Go through and remove any inline script tags that are our data-islands , which have already been boostrapped
    
    @name $sf.host-_clean_up_booted_tags
    @private
    @function
    @static
     */
    _clean_up_booted_tags = function() {
      var script_tag, script_tag_id;
      script_tag_id = void 0;
      script_tag = void 0;
      if (dom) {
        for (script_tag_id in inline_tags_processed) {
          script_tag = _elt(script_tag_id);
          if (script_tag) {
            _purge(script_tag);
            delete inline_tags_processed[script_tag_id];
          }
        }
      }
    };

    /*
    Search for SafeFrames tags and render them. This function is called
    automatically whenever the SafeFrames publisher library is loaded. However a configuration
    can be applied to not have SafeFrames tags automatically be rendered, requiring a controlled
    call to this function.
    
    @name $sf.host.boot
    @public
    @function
    @static
     */
    boot = function() {
      var boot_positions, data, e, err, errMsg, has_booted, html, idx, lib, meta_key, pos_conf, pos_dest_el, pos_meta, pos_meta_item, pos_obj, prv_meta, prv_meta_key, ret, script_tag, script_tag_id, script_tag_par, script_tags, sf_conf, sf_host, sf_inline_conf, sf_ocnf, shared_meta, typ;
      script_tags = (_tags && _tags("script")) || [];
      boot_positions = [];
      idx = 0;
      ret = false;
      errMsg = void 0;
      sf_host = sf && sf.host;
      sf_inline_conf = sf_host && sf_host.conf;
      script_tag = void 0;
      script_tag_par = void 0;
      script_tag_id = void 0;
      data = void 0;
      html = void 0;
      pos_obj = void 0;
      pos_conf = void 0;
      pos_dest_el = void 0;
      pos_meta = void 0;
      pos_meta_item = void 0;
      typ = void 0;
      shared_meta = void 0;
      prv_meta = void 0;
      prv_meta_key = void 0;
      meta_key = void 0;
      sf_ocnf = void 0;
      err = void 0;
      if (!sf || !lang || !dom) {
        _log("SafeFrame base library not found", true);
        return ret;
      }
      if (!lib) {
        lib = sf && sf.lib;
      }
      if (doing_auto_boot && has_booted) {
        _log("Automatic boot already invoked");
        return ret;
      }
      if (win === top) {
        try {
          sf_conf = sf_host.Config();
        } catch (_error) {
          err = _error;
          sf_conf = null;
        }
        if (sf_inline_conf && !sf_conf) {
          try {
            sf_conf = sf_host.Config(sf_inline_conf);
          } catch (_error) {
            e = _error;
            sf_conf = null;
          }
        }
        if (!sf_conf) {
          _log("No configuration found");
          return ret;
        }
      }
      while (script_tag = script_tags[idx++]) {
        if (script_tag.className === SF_DATATAG_CLASS || _attr(script_tag, "type") === SF_TAG_TYPE) {
          has_booted = true;
          script_tag_id = _attr(script_tag, "id");
          if (!script_tag_id) {
            script_tag_id = _guid("sf_data_element");
            _attr(script_tag, "id", script_tag_id);
          }
          if (inline_tags_processed[script_tag_id]) {
            continue;
          }
          data = script_tag.text || script_tag.innerHTML || script_tag.innerText;
          try {
            data = lang.trim(data);
            data = new Function("return " + data);
            data = data();
          } catch (_error) {
            err = _error;
            data = null;
            errMsg = "Error parsing tag configuration " + (err && err.message || "");
            _log(errMsg, true);
            continue;
          }
          if (data && data.id && (data.html || data.src)) {
            if (win !== top) {
              html = data.html || "";
              html = html || _create_pos_markup(data.src);
              if (!_ready()) {
                d.write(html);
              } else {
                _log("cannot write html content into already loaded document");
              }
            } else {
              script_tag_par = _par(script_tag);
              if (!script_tag_par) {
                _log("can't find parent element for script tag", true);
                continue;
              }
              pos_conf = sf_conf && sf_conf.positions[data.id];
              if (!pos_conf) {
                pos_conf = data.conf;
                pos_conf.id = data.id;
                if (pos_conf) {
                  pos_conf = new sf_host.PosConfig(pos_conf);
                }
              }
              if (!pos_conf) {
                _log("no position conf found pre-defined or inline for position " + data.id, true);
                continue;
              }
              if (!pos_conf.dest) {
                pos_conf = new sf_host.PosConfig(pos_conf, _guid(SF_POSELEM_WRAPPER_CLASS));
              }
              if (data.meta) {
                pos_meta = data.meta;
                meta_key = "";
                shared_meta = {};
                for (meta_key in pos_meta) {
                  pos_meta_item = pos_meta[meta_key];
                  typ = typeof pos_meta_item;
                  if (!prv_meta && typ === "object" && pos_meta_item) {
                    prv_meta = pos_meta_item;
                    prv_meta_key = meta_key;
                  }
                  if (typ !== "object" && typ !== "function") {
                    shared_meta[meta_key] = pos_meta_item;
                  }
                }
                pos_meta = new sf_host.PosMeta(shared_meta, prv_meta_key || "", (prv_meta_key && prv_meta ? prv_meta : null));
              }
              pos_obj = new sf_host.Position(data, null, pos_meta, pos_conf);
              inline_tags_processed[script_tag_id] = script_tag_id;
              pos_dest_el = _elt(pos_conf.dest);
              if (!pos_dest_el) {
                if (_ready()) {
                  pos_dest_el = dom.make("div");
                  _attr(pos_dest_el, "id", pos_conf.dest);
                  try {
                    script_tag_par.insertBefore(pos_dest_el);
                  } catch (_error) {
                    err = _error;
                    _log("failed auto-adding destination element " + err.message, true);
                    continue;
                  }
                } else {
                  d.write("<div id='", pos_conf.dest, "'></div>");
                }
              }
              boot_positions.push(pos_obj);
            }
          } else {
            _log("no content or id property found in the inline position object", true);
          }
        }
      }
      if (boot_positions.length) {
        try {
          sf_host.render(boot_positions);
        } catch (_error) {
          e = _error;
          _log("failed during rendering " + e.message);
        }
      } else {
        _log("no positions to boot");
      }
      dom.wait(_clean_up_booted_tags);
    };
    SF_DATATAG_CLASS = "sf_data";
    SF_TAG_TYPE = "text/x-safeframe";
    AUTO_BOOT_MAX_RETRIES = 100;
    SF_POSELEM_WRAPPER_CLASS = "sf_position";
    d = win && win.document;
    lib = sf.lib;
    lang = lib.lang;
    dom = lib.dom;
    _cstr = lang.cstr;
    _guid = lang.guid;
    _elt = dom.elt;
    _par = dom.par;
    _tags = dom.tags;
    _attr = dom.attr;
    _purge = dom.purge;
    _ready = dom.ready;
    inline_tags_processed = {};
    boot_retries = 0;
    has_booted = false;
    doing_auto_boot = false;
    setTimeout(_auto_boot, 50);
    return sf;
  })(window, sf);

}).call(this);

},{"../shared/base":4}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
@namespace $sf.host Defines the Publisher side api, and helper functions
@name $sf.host
@author <a href="mailto:ssnider@yahoo-inc.com">Sean Snider</a>
@author <a href="mailto:ccole[AT]emination.com">Chris Cole</a>
@version 1.0.2
 */


/*
@ignore
 */

(function() {
  var sf;

  sf = require('./boot');

  module.exports = (function(window, sf) {
    var ATTACH, AUTO, AUTO_BOOT_MAX_RETRIES, BF_POS_MSG, CLIP, COLLAPSE_COMMAND, COMPARE_DOC_POS, COMPAT_MODE, CONTAINS, Config, DEFAULT_RENDER_TIMEOUT, DEFAULT_ZINDEX, DETACH, DOC, DOC_EL, EL_FROM_PT, ERROR_COMMAND, EXPAND_COMMAND, FLASH_MIME, GEOM_UPDATE_INTRVAL, GUID, HEIGHT, HIDDEN, IE_BORDER_ADJ, INTERSECT_FACTOR, LEN, M, MSG, NODE_TYPE, NOTIFY_COLLAPSE, NOTIFY_EXPAND, NOTIFY_FOCUS_CHANGE, NOTIFY_GEOM_UPDATE, OBJ, ONSCROLL, OVER, PMSG, POS_ID_AUTO_PREFIX, POS_MSG, POS_REL_BOX_ID_PREFIX, PX, ParamHash, PosConfig, PosMeta, Position, SCROLL, SF_DATATAG_CLASS, SF_POSELEM_WRAPPER_CLASS, ST, STR, SUPPORTS_FEATURES, TFXD, VERSION, WIDTH, XCOM_RESP_DELAY, attach_iframe_msging, bounds, canUseHTML5, complete_ifrs, config, contains, currentStyle, current_status, dc, detach_iframe_msging, docRect, dom, env, flashActiveXVersions, flash_ver, focus_update_timer, geckVer, geom_update_timer, get, html5Bound, ieVer, ifr_dest_id_map, iframes, initID, isIE, lang, lib, loc, locHost, mgr_bounds_details, msg_pipes, msghostfb, nuke, operaVer, overlaps, pending_ifrs, prep_iframe_msging, render, rendered_ifrs, scroll_parents_attached, send_msg_to_child_iframe, status, ua, usingHTML5, wbVer, win, winRect, win_events_attached, _attr, _build_geom, _calcBorders, _call_xmsg_host_fb, _callable, _cbool, _check_html5_init, _clear_focus_update_timer, _clear_geom_update_timer, _cnum, _collapse_safeframe, _cookieHash, _cookies_enabled_test, _create_pos_markup, _cstr, _doc, _docNode, _elt, _es, _expand_safeframe, _fire_pub_callback, _getClip, _getRectIE, _getRectNonIE, _get_doc_scroll, _get_flash_version, _guid, _handle_frame_load, _handle_msg_evt, _handle_msg_from_outside, _handle_node_scroll, _handle_render_timeout, _handle_unload, _handle_win_blur, _handle_win_focus, _handle_win_geom_resize, _handle_win_geom_scroll, _has_pending_renders, _ifr_view, _isPX, _max, _min, _mix, _noop, _par, _purge, _read_cookie, _ready, _record_error, _rect, _round, _send_response, _set_focus_update_timer, _set_geom_update_timer, _shim_frame, _strippedEncodedLocation, _tagName, _tags, _update_focus, _update_geom, _update_geom_win_resize, _update_geom_win_scroll, _view, _write_cookie;
    win = window;
    DEFAULT_RENDER_TIMEOUT = 60000;
    POS_ID_AUTO_PREFIX = "sf_pos";
    POS_REL_BOX_ID_PREFIX = "sf_pos_rel_el";
    SF_DATATAG_CLASS = "sf_data";
    SF_POSELEM_WRAPPER_CLASS = "sf_position";
    AUTO_BOOT_MAX_RETRIES = 100;
    GEOM_UPDATE_INTRVAL = 100;
    XCOM_RESP_DELAY = 1;
    IE_BORDER_ADJ = 2;
    INTERSECT_FACTOR = 10;
    BF_POS_MSG = "onBeforePosMsg";
    POS_MSG = "onPosMsg";
    SUPPORTS_FEATURES = {
      "exp-ovr": 1,
      "exp-push": 0,
      bg: 0,
      pin: 0,
      "read-cookie": 0,
      "write-cookie": 0
    };
    EXPAND_COMMAND = "exp-ovr";
    COLLAPSE_COMMAND = "collapse";
    ERROR_COMMAND = "error";
    NOTIFY_EXPAND = "expand";
    NOTIFY_GEOM_UPDATE = "geom-update";
    NOTIFY_COLLAPSE = COLLAPSE_COMMAND;
    NOTIFY_FOCUS_CHANGE = "focus-change";
    DEFAULT_ZINDEX = 3000;
    OBJ = "object";
    STR = "string";
    ST = "style";
    LEN = "length";
    WIDTH = "width";
    HEIGHT = "height";
    PX = "PX";
    CLIP = "clip";
    SCROLL = "scroll";
    ONSCROLL = "onscroll";
    COMPAT_MODE = "compatMode";
    DOC_EL = "documentElement";
    DOC = "document";
    NODE_TYPE = "nodeType";
    CONTAINS = "contains";
    COMPARE_DOC_POS = "compareDocumentPosition";
    EL_FROM_PT = "elementFromPoint";
    AUTO = "auto";
    HIDDEN = "hidden";
    OVER = "overflow";
    TFXD = "toFixed";
    ATTACH = "attach";
    DETACH = "detach";
    MSG = "message";
    PMSG = "postMessage";
    GUID = "guid";
    FLASH_MIME = "application/x-shockwave-flash";
    VERSION = sf.ver;
    env = sf.env;
    ua = env.ua;
    lib = sf.lib;
    lang = lib.lang;
    dom = lib.dom;
    iframes = dom.iframes;
    _cbool = lang.cbool;
    _cnum = lang.cnum;
    _cstr = lang.cstr;
    _callable = lang.callable;
    _noop = lang.noop;
    _guid = lang[GUID];
    _mix = lang.mix;
    _elt = dom.elt;
    _par = dom.par;
    _tags = dom.tags;
    _attr = dom.attr;
    _doc = dom.doc;
    _tagName = dom.tagName;
    _view = dom.view;
    _ifr_view = iframes.view;
    _purge = dom.purge;
    _ready = dom.ready;
    _es = win && win.escape;
    M = win && win.Math;
    _max = M.max;
    _min = M.min;
    _round = M.round;
    _rect = null;
    ParamHash = lang && lang.ParamHash;
    dc = win && win[DOC];
    isIE = env && env.isIE;
    ieVer = (ua && ua.ie) || 0;
    wbVer = (ua && ua.webkit) || 0;
    geckVer = (ua && ua.gecko) || 0;
    operaVer = (ua && ua.opera) || 0;
    loc = win.location;
    locHost = loc && ((loc.protocol + "//" + (loc.host || loc.hostname)) || "");
    rendered_ifrs = {};
    msg_pipes = {};
    ifr_dest_id_map = {};
    pending_ifrs = {};
    complete_ifrs = {};
    scroll_parents_attached = {};
    mgr_bounds_details = false;
    canUseHTML5 = false;
    html5Bound = false;
    win_events_attached = false;
    geom_update_timer = 0;
    focus_update_timer = 0;
    current_status = null;
    msghostfb = null;
    flash_ver = null;
    config = null;
    flashActiveXVersions = ["ShockwaveFlash.ShockwaveFlash.11", "ShockwaveFlash.ShockwaveFlash.8", "ShockwaveFlash.ShockwaveFlash.7", "ShockwaveFlash.ShockwaveFlash.6", "ShockwaveFlash.ShockwaveFlash"];
    initID = void 0;

    /*
    Configure the base-level settings for the SafeFrames library
    Note that only one configuration can be active at a given time.
    Therefore you cannot change the configuration by creating a new $sf.host.Config while
    the SafeFrames library is busy (however you can add new position configurations).
    Instatiating a new config, when the library is not busy will destroy / remove all currently
    managed positions and there configurations.
    
    @name $sf.host.Config
    @constructor
    @public
    @param {Object} conf An object containing properties for configuration
    @param {Boolean} [conf.auto] Whether or not to have SafeFrames automatically boostrap an render any SafeFrames tags within the page
    @param {String} conf.cdn The protocol,host name, and port parts of a URI, that is a 2ndary origin, used with SafeFrames to render content. For example JS files would be loaded from conf.cdn+"/"+conf.root+"/"+conf.version+"/[filename]"
    @param {Boolean} [conf.debug] Whether or not debug mode is on or off
    @param {String} conf.root The root path part of the URI that is a 2ndary origin, used with SafeFrames to render content. For example the HTML file for rendering content into would beloaded from conf.cdn+"/"+conf.root+"/"+conf.version+"/"+conf.renderFile
    @param {String} conf.renderFile The filename (may also include path info), for which to render content into via a SafeFrame.
    @param {String} [conf.msgFile] The filename (may also include path info), for which to use as a proxy for x-domain messaging whenever HTML5 messaging is not available. Only required if supporting older browsers.
    @param {Number} [conf.to] The maximum amount of time in milliseconds to wait for a SafeFrame to finish rendering, defaults to 60 seconds.
    @param {Function} [conf.onBeforePosMsg] A callback function that gets fired before any cancellable action is requested to be peformed from a a SafeFrame, such as expansion, etc.  Return true out of this callback function to cancel/disallow the action in question.
    @param {Function} [conf.onPosMsg] A callback function that gets fired when an action requested by a SafeFrame is performed
    @param {Function} [conf.onStartPosRender] A callback function that gets fired when a SafeFrame starts to render 3rd party content.
    @param {Function} [conf.onEndPosRender] A callback function that gets fired when a SafeFrame finishes rendering 3rd party content.
    @param {Object} [conf.positions] A map of positions to automatically configure, where each key equals the id of the $sf.host.PosConfig object, and the value is an object containing said object's settings.
     */
    Config = function(conf) {
      var boot_up, conf_pos_map, me, posID, pos_conf, pos_id, pos_map;
      me = this;
      if (!arguments.length) {
        return (config ? _mix({}, config) : null);
      }
      if (!(me instanceof Config)) {
        return new Config(conf);
      }
      if (!conf) {
        config = null;
        return null;
      }
      boot_up = !!config;
      me.auto = ("auto" in conf ? _cbool(conf.auto) : true);
      me.cdn = _cstr(conf.cdn);
      me.debug = _cbool(conf.debug);
      me.root = _cstr(conf.root);
      me.renderFile = _cstr(conf.renderFile);
      me.msgFile = _cstr(conf.msgFile);
      me.to = _cnum(conf.to, DEFAULT_RENDER_TIMEOUT);
      me.ver = _cstr(conf.ver) || VERSION;
      me.onBeforePosMsg = (_callable(conf.onBeforePosMsg) ? conf.onBeforePosMsg : _noop);
      me.onPosMsg = (_callable(conf.onPosMsg) ? conf.onPosMsg : _noop);
      me.onStartPosRender = (_callable(conf.onStartPosRender) ? conf.onStartPosRender : _noop);
      me.onEndPosRender = (_callable(conf.onEndPosRender) ? conf.onEndPosRender : _noop);
      me.onFailure = (_callable(conf.onFailure) ? conf.onFailure : _noop);
      conf_pos_map = conf.positions;
      me.positions = pos_map = {};
      if (conf_pos_map) {
        for (posID in conf_pos_map) {
          pos_conf = conf_pos_map[posID];
          if (pos_conf && typeof pos_conf === OBJ) {
            pos_id = posID || pos_conf.id || _guid(POS_ID_AUTO_PREFIX);
            pos_map[pos_id] = new PosConfig(pos_conf);
          }
        }
      }
      config = me;
      boot_up = !!(boot_up && me.auto && (sf.host.boot != null));
      try {
        if (boot_up) {
          sf.host.boot();
        }
      } catch (_error) {}
      return _mix({}, config);
    };

    /*
    Configure a particualar position for rendering a SafeFrame
    Each $sf.host.PosConfig object has an id property that should be unique.  Creating a new $sf.host.PosConfig with an id, that has already been
    used results in changing the old $sf.host.PosConfig settings, and can only be done if the SafeFrames library is not busy.
    Automatically ads to the position map of the $sf.host.Config object if said config has already been created.
    
    @name $sf.host.PosConfig
    @public
    @constructor
    @param {Object|String} posIDorObj The id of the $sf.host.PosConfig instance, or an object containing all settings that are to be used for the instance.
    @param {String} [posIDorObj.id] The id of the $sf.host.PosConfig instance, if not specified one will be generated automatically.
    @param {String} [posIDorObj.dest] The HTML element id attribute of the HTML element in the document where a SafeFrame will be rendered. Said element MUST exist within the page prior to a render.
    @param {String} [posIDorObj.bg] The color of the background to be used inside the SafeFrame. Default equals "transparent".
    @param {String} [posIDorObj.tgt] The name of the target window where hyperlinks inside a SafeFrame will navigate too...Note that "_self" is not allowed and always converted to "_top". Allowed values are any string value not prefixed with "_", or "_top" or "_blank".
    @param {String} [posIDorObj.css] A string of CSS rules, or a URL that points to a CSS style sheet to be used inside the SafeFrame
    @param {Number} [posIDorObj.w] The width of the SafeFrame, specified in pixels. Cannot be specified in em, % or another values.
    @param {Number} [posIDorObj.h] The height of the SafeFrame, specified in pixels. Cannot be specified in em, % or another values.
    @param {String} [posIDorObj.size] A string formated as "widthXheight", that defines the width and height of the SafeFrame. The delimiter character "X" is can be specified as lower or upper case.
    @param {String} [posIDorObj.z] The z-index of the SafeFrame.
    @param {Object} [posIDorObj.supports] An object containing key/value pairs for what features/actions are supported by the SafeFrame, and its corresponding value represents a boolean detereming whether that feature can be used.  Currently supported keys are "exp-ovr" == SafeFrame can expand in overlay mode, "exp-push" == SafeFrame can expand in push mode, and "bg" == SafeFrame can change the background of the publisher / host.
    @param {String} [destID] The HTML element id attribute of the HTML element in the document where a SafeFrame will be rendered. Said element MUST exist within the page prior to a render.
    @param {Object} [baseConf] An object representing a $sf.host.Config object to automatically use / create for the SafeFrames library. Note that baseConf can only be used one time, otherwise you have to use the $sf.host.Config object directly.
     */
    PosConfig = function(posIDorObj, destID, baseConf) {
      var me, sz, sz_split, typ;
      me = this;
      typ = (posIDorObj && typeof posIDorObj) || "";
      if (!(me instanceof PosConfig)) {
        return new PosConfig(posIDorObj, destID, baseConf);
      }
      if (typ === OBJ) {
        me.id = _cstr(posIDorObj.id);
        me.dest = _cstr(posIDorObj.dest || destID);
        me.bg = _cstr(posIDorObj.bg) || "transparent";
        me.tgt = _cstr(posIDorObj.tgt) || "_top";
        me.css = _cstr(posIDorObj.css);
        me.w = _cnum(posIDorObj.w, 0);
        me.h = _cnum(posIDorObj.h, 0);
        me.z = _cnum(posIDorObj.z, 0);
        me.supports = _mix({}, posIDorObj.supports || SUPPORTS_FEATURES, true, true, true);
        if (!me.w || !me.h) {
          sz = _cstr(posIDorObj.size);
          if (sz) {
            sz_split = sz.split(/x/g);
            me.w = _cnum(sz_split[0], 0);
            me.h = _cnum(sz_split[1], 0);
            me.size = sz;
          } else {
            me.size = "";
          }
        } else {
          me.size = me.w + "x" + me.h;
        }
      } else if (typ === "string") {
        me.id = _cstr(posIDorObj);
        me.dest = _cstr(destID);
      } else {
        me.dest = "";
        me.bg = "transparent";
        me.tgt = "_top";
        me.css = "";
        me.w = 0;
        me.h = 0;
        me.size = "";
        me.z = 0;
        me.supports = {};
      }
      me.id = me.id || _guid(POS_ID_AUTO_PREFIX);
      if (!config && baseConf) {
        Config(baseConf);
      }
      if (config) {
        config.positions[me.id] = me;
      }
      return _mix({}, me);
    };

    /*
    Construct a set of dynamic key/value pairs that can be shared as meta-data with the 3rd party content inside a SafeFrame.
    All data is treated as protected, and can only be specfied during construction of this object.
    
    @exports PosMeta as $sf.host.PosMeta#
    @public
    @constructor
    @class
    @param {Object} shared_object An object containing keys and values to be shared as meta-data inside the SafeFrame
    @param {String} [owner_key] A key name to be used to hold pseudo private keys / values of meta data.
    @param {Object} [owned_obj] An object containing psuedo private keys and values to be shared as meta-data inside the SafeFrame.
    @example
    var shared_data 		 = {content_id:8978098,partner_id:99},
    private_data_key	 = "rmx",
    private_data      = {section_id:2342,site_id:23904},
    meta_data		 = new $sf.host.PosMeta(shared_data, private_data_key, private_data);
    
    //show section id on host side
    alert(meta_data.value("rmx", "site_id")); //== 23904
    
    @example
    //now retrieve this information inside the safe frame
    
    var content_id = $sf.vend.meta("content_id"); //== 8978098
    
    var rmx_section_id = $sf.vend.meta("rmx", "section_id") //== 2342, but note that vendor side code must know the "owner_key" upfront.
     */
    PosMeta = function(shared_obj, owner_key, owned_obj) {

      /*
      A method retrieves a meta data value from this object.
      
      @exports get_value as $sf.host.PosMeta#value
      @param {String} propKey The name of the value to retrieve
      @param {String} [owner_key] The name of the owner key of the meta data value. By default, it is assumed to be shared, so nothing needs to be passed in unless looking for a specific proprietary value
      @return {String|Number|Boolean}
      @default {String} ""
      @public
      @function
       */
      var get_value, me, non_shared, old, posConf, serialize, shared;
      get_value = function(propKey, owner_key) {
        var ret;
        ret = "";
        if (!propKey || typeof propKey !== STR) {
          return ret;
        }
        if (!owner_key || typeof owner_key !== STR) {
          owner_key = "shared";
        }
        if (owner_key === "shared") {
          ret = shared[propKey] || "";
        } else {
          ret = (propKey in non_shared ? non_shared[prop_key] || "" : "");
        }
        return ret;
      };

      /*
      Return a serialized string representation (in url query string format) of the meta data object
      
      @exports serialize as $sf.host.PosMeta#toString
      @function
      @public
       */
      serialize = function() {
        var obj;
        obj = new ParamHash();
        obj.shared = shared;
        obj.non_shared = non_shared;
        return obj.toString();
      };
      me = this;
      shared = void 0;
      non_shared = void 0;
      old = void 0;
      posConf = void 0;
      if (!(me instanceof PosMeta)) {
        return new PosMeta(key, owned_obj, pos, shared_obj);
      }
      shared = {};
      non_shared = {};
      if (!owner_key || typeof owner_key !== STR) {
        return me;
      }
      if (shared_obj && typeof shared_obj === OBJ) {
        shared = _mix(shared, shared_obj);
      }
      if (owned_obj && typeof owned_obj === OBJ) {
        non_shared[owner_key] = owned_obj;
      }
      me.toString = serialize;
      me.value = get_value;
    };

    /*
    Create the HTML markup for a position if a src property was used
    
    @name $sf.host-_create_pos_markup
    @function
    @private
    @static
    @return {String}
     */
    _create_pos_markup = function(src) {
      var ckVal, fVer;
      if (src) {
        if (src.indexOf("${sf_ver}") > -1) {
          src = src.replace(/\${sf_ver}/g, $sf.ver);
        }
        if (src.indexOf("${ck_on}") > -1) {
          ckVal = (_cookies_enabled_test() ? "1" : "0");
          src = src.replace(/\${ck_on}/g, ckVal);
        }
        if (src.indexOf("${flash_ver}") > -1) {
          fVer = _get_flash_version();
          src = src.replace(/\${flash_ver}/g, fVer);
        }
      }
      return _cstr(["<scr", "ipt type='text/javascript', src='", src, "'></scr", "ipt>"]);
    };

    /*
    Get the falsh version number
     */
    _get_flash_version = function() {
      var err, getActiveXVersion, i, mimeTypes, obj, p, tmpVer;
      if (flash_ver !== null) {
        return flash_ver;
      }
      if (navigator.plugins && navigator.plugins.length > 0) {
        mimeTypes = navigator.mimeTypes;
        if (mimeTypes && mimeTypes[FLASH_MIME] && mimeTypes[FLASH_MIME].enabledPlugin && mimeTypes[FLASH_MIME].enabledPlugin.description) {
          flash_ver = mimeTypes[FLASH_MIME].enabledPlugin.version;
        }
      } else if (sf.env.isIE) {
        i = 0;
        while (i < flashActiveXVersions.length) {
          try {
            obj = new ActiveXObject(flashActiveXVersions[i]);
            tmpVer = obj.GetVariable("$version");
            p = tmpVer.indexOf(" ");
            if (p > -1) {
              flash_ver = tmpVer.substr(p + 1).replace(/,/g, ".");
            } else {
              flash_ver = tmpVer.replace(/,/g, ".");
            }
            break;
          } catch (_error) {
            err = _error;
            obj = null;
            flash_ver = 0;
            continue;
          }
          i++;
        }
      } else {
        flash_ver = 0;
      }
      return flash_ver;
      getActiveXVersion = function(activeXObj) {
        var version;
        version = -1;
        try {
          version = activeXObj.GetVariable("$version");
        } catch (_error) {}
        return version;
      };
    };

    /*
    Test to see if cookies are enabled
     */
    _cookies_enabled_test = function() {
      var cookieEnabled;
      cookieEnabled = (navigator.cookieEnabled ? true : false);
      if (typeof navigator.cookieEnabled === "undefined" && !cookieEnabled) {
        document.cookie = "testcookie";
        cookieEnabled = (document.cookie.indexOf("testcookie") !== -1 ? true : false);
        if (navigator) {
          navigator.cookieEnabled = cookieEnabled;
        }
      }
      return cookieEnabled;
    };

    /*
    Construction a postion content object that contains HTML, optionally meta-data, and optionally a position configuration to use.
    The id specified must match an id for a $sf.host.PosConfig (although said config could be specfied directly here via arguments).
    
    @name $sf.host.Position
    @constructor
    @public
    @param {Object|String} posIDorObj The id of the position which maps to its configuration, or an object represeting the various values of an $sf.host.Position instance.
    @param {String} [posIDorObj.id] The id of the position which maps to its configuration.
    @param {String} [posIDorObj.html] The HTML content to be rendered inside the SafeFrame. Note that HTML strings which have SCRIPT tags or other special characters may need to be properly escaped in order to avoid JavaScript syntax errors.
    @param {String} [posIDorObj.src] An optional URL to be used for redering inside the SafeFrame which will automatically generate a SCRIPT tag with the specified URL.
    @param {$sf.host.PosMeta} [posIDorObj.meta] An optional instance of the $sf.host.PosMeta object to be passed along into the SafeFrame
    @param {Object} [posIDorObj.conf] An optional representation of an $sf.host.PosConfig object to be used as the configuration for the SafeFrame position.
    @param {String} [html] The HTML content to be rendered inside the SafeFrame. Note that HTML strings which have SCRIPT tags or other special characters may need to be properly escaped in order to avoid JavaScript syntax errors.
    @param {$sf.host.PosMeta} [meta] An optional instance of the $sf.host.PosMeta object to be passed along into the SafeFrame
    @param {Object} [conf] An optional representation of an $sf.host.PosConfig object to be used as the configuration for the SafeFrame position.
     */
    Position = function(posIDorObj, html, meta, conf) {
      var id, me, msg, origHtml, typ;
      me = this;
      typ = posIDorObj && typeof posIDorObj;
      origHtml = html;
      if (!(me instanceof Position)) {
        return new Position(posIDorObj, html, meta, conf);
      }
      if (config == null) {
        msg = "Publisher Config not initialized - abort";
        sf.lib.logger.error(msg);
        sf.info.errs.push(msg);
        return;
      }
      if (typ === OBJ) {
        _mix(me, posIDorObj);
      } else {
        id = me.id = _cstr(posIDorObj) || _guid(POS_ID_AUTO_PREFIX);
      }
      if (!html) {
        if (me.src) {
          me.html = _create_pos_markup(me.src);
        } else {
          me.html = me.html || "";
          me.src = "";
        }
      } else {
        me.html = html;
        me.src = "";
      }
      if (!me.html) {
        me.html = "";
      }
      me.meta = meta || me.meta || {};
      me.conf = conf || me.conf || {};
      if (id) {
        if (config && config.positions[id]) {
          me.conf = config.positions[id];
        } else {
          if (conf) {
            conf.id = id;
            me.conf = new PosConfig(conf);
          }
        }
      }
    };

    /*
    @namespace $sf.lib.dom.msghost Contains functionality to reside in the top level page for sending and receiving x-domain messages to SafeFrame containers
    @name $sf.lib.dom.msghost
     */

    /*
    Returns the root document HTMLElement / node
    @name $sf.lib.dom-_docNode
    @private
    @static
    @function
    @param {HTMLElement} [el] An HTMLElement to use as a reference for finding the root document element.
    @returns {HTMLElement}
     */
    _docNode = function(el) {
      var compatMode, d, root;
      d = (el && _doc(el)) || dc;
      compatMode = d[COMPAT_MODE];
      root = d[DOC_EL];
      if (compatMode && !operaVer && compatMode !== "CSS1Compat") {
        root = d.body;
      }
      return root;
    };

    /*
    Returns whether or not a value is specified in pixels
    @name $sf.lib.dom-_isPX
    @private
    @static
    @function
    @param {String} val A css value of size
    @returns {Boolean}
     */
    _isPX = function(val) {
      val = _cstr(val);
      if (val && val.search(/\D+/g) === -1) {
        return true;
      }
      if (val && val.search(/px/g) !== -1) {
        return true;
      }
    };

    /*
    Return an array of values of clipping region information. Array represents top, right, bottom, left values respectively.
    If values are not specified in pixels, or no clip region is defined for that element, -1 is returned for each value.
    
    @name $sf.lib.dom-_getClip
    @private
    @function
    @static
    @param {HTMLStyleObject} curSt The current style object of an HTMLElement
    @return {Array}
     */
    _getClip = function(curSt) {
      var clipVal, idx, len, prop, props, ret, val;
      ret = [-1, -1, -1, -1];
      props = [CLIP + "Top", CLIP + "Right", CLIP + "Bottom", CLIP + "Left"];
      idx = 0;
      clipVal = void 0;
      prop = void 0;
      val = void 0;
      len = void 0;
      if (!curSt) {
        return ret;
      }
      if (ieVer) {
        while (prop = props[idx]) {
          clipVal = curSt[prop];
          if (_isPX(clipVal)) {
            clipVal = _cnum(clipVal, -1);
            if (clipVal >= 0) {
              ret[idx] = clipVal;
            }
          }
          idx++;
        }
      } else {
        clipVal = curSt[CLIP];
        if (clipVal && clipVal.search(/\d+/g) !== -1) {
          clipVal = clipVal.replace(/\w+\(([^\)]*?)\)/g, "$1");
          ret = clipVal.split(" ");
          ret = (ret[LEN] <= 1 ? ret.split(",") : ret);
          len = ret[LEN];
          idx = 0;
          while (len--) {
            val = ret[idx];
            if (!_isPX(val)) {
              ret[idx] = -1;
            } else {
              ret[idx] = _cnum(val, -1);
            }
            idx++;
          }
        }
      }
      return ret;
    };

    /*
    Returns border values in pixels if possible to help calculate geometry of an element
    
    @name $sf.lib.dom-_calcBorders
    @private
    @static
    @function
    @param {HTMLElement} el The HTMLElement for which to look at. . .
    @param {Object} rect The rect object generated for the HTMLElement in question to be adjusted
    @returns {Object} rect
     */
    _calcBorders = function(el, rect) {
      var l, re, st, t;
      t = 0;
      l = 0;
      st = void 0;
      re = /^t(?:able|d|h|r|head|foot)$/i;
      st = currentStyle(el);
      if (st) {
        t = st["borderTopWidth"];
        l = st["borderLeftWidth"];
        t = (_isPX(t) ? _cnum(t, 0) : 0);
        l = (_isPX(l) ? _cnum(l, 0) : 0);
        if (geckVer && re.test(_tagName(el))) {
          t = l = 0;
        }
      }
      rect = rect || {
        t: 0,
        l: 0
      };
      rect.t += t;
      rect.l += l;
      return rect;
    };

    /*
    Retrieve scroll values of a document
    
    @name $sf.lib.dom-_get_doc_scroll
    @private
    @static
    @function
    @param {HTMLElement} [el] An HTMLElement to use as a reference document rather than the default main document
    @return {Object} Contains x, y, w, h properties for scrolling
     */
    _get_doc_scroll = function(el) {
      var d, db, de, def, dv, offsetX, offsetY, pos;
      pos = {
        x: 0,
        y: 0,
        w: 0,
        h: 0
      };
      def = {
        scrollLeft: 0,
        scrollTop: 0,
        scrollWidth: 0,
        scrollHeight: 0
      };
      d = void 0;
      de = void 0;
      dv = void 0;
      db = void 0;
      offsetX = 0;
      offsetY = 0;
      d = _doc(el) || dc;
      de = d[DOC_EL] || def;
      db = d.body || def;
      dv = d.defaultView;
      if (dv) {
        offsetX = _cnum(dv.pageXOffset, 0);
        offsetY = _cnum(dv.pageYOffset, 0);
      }
      pos.x = _max(de.scrollLeft, db.scrollLeft, offsetX);
      pos.y = _max(de.scrollTop, db.scrollTop, offsetY);
      pos.w = _max(de.scrollWidth, db.scrollWidth, 0);
      pos.h = _max(de.scrollHeight, db.scrollHeight, 0);
      return pos;
    };

    /*
    Calculate a geometric rectangle for a given element. Note that for IE browsers
    we can use the "getBoundingClientRect" function which saves us some time / increases
    peformance. . however it really can only be called if the DOM is completely loaded,
    and if that is the case we fallback to the brute-force / non-IE method.
    
    @name $sf.lib.dom-_getRectIE
    @private
    @static
    @function
    @param {HTMLElement} el  The element for which to derive a rectangle object
    @returns {Object} An object representing the rectangle for the given HTMLElement
     */
    _getRectIE = function(el) {
      var adjustX, adjustY, bLeft, bTop, box, compatMode, d, de, e, rect, scroll, st, _back;
      rect = {
        t: 0,
        l: 0,
        r: 0,
        b: 0,
        w: 0,
        h: 0,
        z: 0
      };
      _back = "BackCompat";
      scroll = void 0;
      box = void 0;
      d = void 0;
      de = void 0;
      compatMode = void 0;
      st = void 0;
      adjustX = void 0;
      adjustY = void 0;
      bLeft = void 0;
      bTop = void 0;
      if (el && el[NODE_TYPE] === 1) {
        try {
          d = _doc(el) || dc;
          if (!dom.ready()) {
            return _getRectNonIE(el);
          }
          scroll = _get_doc_scroll(el);
          box = el.getBoundingClientRect();
          rect.t = box.top;
          rect.l = box.left;
          adjustX = adjustY = IE_BORDER_ADJ;
          compatMode = d[COMPAT_MODE];
          de = d[DOC_EL];
          st = currentStyle(de);
          bLeft = st["borderLeftWidth"];
          bTop = st["borderTopWidth"];
          if (ieVer === 6) {
            if (compatMode !== _back) {
              adjustX = adjustY = 0;
            }
          }
          if (compatMode === _back) {
            bLeft = (_isPX(bLeft) ? _cnum(bLeft, 0) : 0);
            adjustX = bLeft;
            bTop = (_isPX(bTop) ? _cnum(bTop, 0) : 0);
            adjustY = bTop;
            rect.t -= adjustX;
            rect.l -= adjustY;
          }
          rect.t += scroll.y;
          rect.l += scroll.x;
          rect.b = rect.t + el.offsetHeight;
          rect.r = rect.l + el.offsetWidth;
          rect.w = _max(rect.r - rect.l, 0);
          rect.h = _max(rect.b - rect.t, 0);
          rect.z = currentStyle(el, "zIndex");
        } catch (_error) {
          e = _error;
          rect = {
            t: 0,
            l: 0,
            r: 0,
            b: 0,
            w: 0,
            h: 0,
            z: 0
          };
        }
      }
      return rect;
    };

    /*
    Calculate a geometric rectangle for a given element. For non-IE browsers, we must use
    brute-force and walk up the offsetParent tree. Also takes in consideration for some
    other slight variations in browsers.
    
    @name $sf.lib.dom-_getRectNonIE
    @private
    @static
    @function
    @param {HTMLElement} el  The element for which to derive a rectangle object
    @returns {Object} An object representing the rectangle for the given HTMLElement
     */
    _getRectNonIE = function(el) {
      var bCheck, e, h, parentNode, rect, root, scroll, scrollLeft, scrollTop, w;
      rect = {
        t: 0,
        l: 0,
        r: 0,
        b: 0,
        w: 0,
        h: 0,
        z: 0
      };
      scrollTop = 0;
      scrollLeft = 0;
      bCheck = false;
      root = _docNode(el);
      scroll = _get_doc_scroll(el);
      parentNode = void 0;
      w = void 0;
      h = void 0;
      if (el && el[NODE_TYPE] === 1) {
        try {
          rect.l = el.offsetLeft || 0;
          rect.t = el.offsetTop || 0;
          parentNode = el;
          bCheck = geckVer || wbVer > 519;
          while (parentNode = parentNode.offsetParent) {
            rect.t += parentNode.offsetTop || 0;
            rect.l += parentNode.offsetLeft || 0;
            if (bCheck) {
              _calcBorders(parentNode, rect);
            }
            if (parentNode === root) {
              break;
            }
          }
          parentNode = el;
          if (currentStyle(parentNode, "position") !== "fixed") {
            parentNode = el;
            while (parentNode = _par(parentNode)) {
              if (parentNode[NODE_TYPE] === 1) {
                scrollTop = parentNode.scrollTop || 0;
                scrollLeft = parentNode.scrollLeft || 0;
                if (geckVer && currentStyle(parentNode, OVER) !== "visible") {
                  _calcBorders(parentNode, rect);
                }
                rect.l -= scrollLeft;
                rect.t -= scrollTop;
              }
              if (parentNode === root) {
                break;
              }
            }
            rect.t += scroll.y;
            rect.l += scroll.x;
          } else {
            rect.t += scroll.y;
            rect.l += scroll.x;
          }
          if (!ieVer && el === _docNode(el)) {
            h = el.clientHeight;
            w = el.clientWidth;
          } else {
            h = el.offsetHeight;
            w = el.offsetWidth;
          }
          rect.b = rect.t + h;
          rect.r = rect.l + w;
          rect.w = _max(rect.r - rect.l, 0);
          rect.h = _max(rect.b - rect.t, 0);
          rect.z = currentStyle(el, "zIndex");
        } catch (_error) {
          e = _error;
          rect = {
            t: 0,
            l: 0,
            r: 0,
            b: 0,
            w: 0,
            h: 0,
            z: 0
          };
        }
      }
      return rect;
    };

    /*
    Returns an object that represents a rectangle with the geometric information of an HTMLDocument
    (includes scroll width / height)
    
    @name $sf.lib.dom.docRect
    @public
    @static
    @function
    @param {HTMLElement} [el] An HTMLElement to use as the reference for an HTMLDocument
    @returns {Object}
     */
    docRect = function(el) {
      var h, root, w;
      root = _docNode(el);
      w = 0;
      h = 0;
      if (root) {
        w = root.scrollWidth || 0;
        h = root.scrollHeight || 0;
      }
      return {
        t: 0,
        l: 0,
        b: h,
        r: w,
        w: w,
        h: h
      };
    };

    /*
    Returns an object that represents a rectangle with the geometric information of an HTMLWindow
    (does not include scroll width / height)
    
    @name $sf.lib.dom.winRect
    @public
    @static
    @function
    @param {HTMLElement} [el] An HTMLElement to use as the references for an HTMLWindow
    @returns {Object}
     */
    winRect = function(el) {
      var b, h, l, r, root, t, w, wi;
      wi = (el && _view(el)) || win;
      h = wi.innerHeight || 0;
      w = wi.innerWidth || 0;
      t = wi.screenY || wi.screenTop || 0;
      b = h + t;
      l = wi.screenX || wi.screenLeft || 0;
      r = w + l;
      root = _docNode(el);
      if (!h && !w && root) {
        h = root.clientHeight || 0;
        w = root.clientWidth || 0;
        r = l + w;
        b = t + h;
      }
      return {
        t: t,
        l: l,
        b: b,
        r: r,
        w: w,
        h: h
      };
    };

    /*
    Returns whether or not an HTMLElement is contained within another HTMLElement
    
    @name $sf.lib.dom.contains
    @public
    @static
    @function
    @param {HTMLElement} element The HTMLElement reference to search within
    @param {HTMLElement} needle The HTMLElement for which you want to check if its contained by the 1st parameter
    @returns {Boolean}
     */
    contains = function(element, needle) {
      var el_node_type, needle_node_type, ret;
      ret = false;
      el_node_type = (element && element[NODE_TYPE]) || -1;
      needle_node_type = (needle && needle[NODE_TYPE]) || -1;
      if (el_node_type === 1 && needle_node_type !== -1) {
        if (element[CONTAINS]) {
          if (operaVer || needle_node_type === 1) {
            ret = element[CONTAINS](needle);
          } else {
            while (needle) {
              if (element === needle) {
                ret = true;
                break;
              }
              needle = needle.parentNode;
            }
          }
        } else {
          if (element[COMPARE_DOC_POS]) {
            ret = element === needle || !!(element[COMPARE_DOC_POS](needle) & 16);
          }
        }
      }
      return ret;
    };

    /*
    Returns the current value of a style attribute, or the current style object in its entirety depending on whether an attribute parameter is specified
    
    @name $sf.lib.dom.currentStyle
    @public
    @static
    @function
    @param {HTMLElement} el The HTMLElement for which to retrieve style information
    @param {String} [attr] The style attribute (in JavaScript notation, e.g. 'backgroundColor' rather than 'background-color') to fetch.
    @return {HTMLStyleObject} An HTMLStyleObject containing all current style attribute values
    @return {String} The value of an style attribute (only if attr parameter is specified).
     */
    currentStyle = function(el, attr) {
      var comp, e, hasAttr, val;
      val = "";
      hasAttr = !!(arguments.length && attr);
      comp = "getComputedStyle";
      e = void 0;
      if (hasAttr) {
        if (ieVer) {
          try {
            val = el.currentStyle[attr];
          } catch (_error) {
            e = _error;
            val = "";
          }
        } else {
          try {
            val = _view(el)[comp](el, null)[attr];
          } catch (_error) {
            e = _error;
            val = "";
          }
        }
      } else {
        if (ieVer) {
          try {
            val = el.currentStyle;
          } catch (_error) {
            e = _error;
            val = null;
          }
        } else {
          try {
            val = _view(el)[comp](el, null);
          } catch (_error) {
            e = _error;
            val = null;
          }
        }
      }
      return val;
    };

    /*
    Calculate the surrounding boundaries of an HTMLElement, and whether or not the HTMLElement is "in-view" of the user
    
    @name $sf.lib.dom.bounds
    @public
    @static
    @function
    @param {HTMLElement} el The element for which to calculate information
    @param {Object} [details] An object reference used as an output parameter in which further details about the boundaries of the element are specified
    @param {Boolean} [check_3D] Check the element within 3 dimensional space such that any elements covering said element are also take into consideration
    @returns {Object} info An object containing information about the element boundaries
     */
    bounds = function(el, details, check_3D) {
      var b, client_height, client_width, clip, clip_rect, cur_st, doc_rect, el_rect, exp_rect, h, is_scroll_node, is_using_doc_root_b, is_using_doc_root_r, l, offset_height, offset_width, over_x_val, over_y_val, par, r, ref_node, root, root_rect, root_scroll, scroll_height, scroll_left, scroll_top, scroll_width, t, temp_rect, w, x_hidden, xsb_h, y_hidden, ysb_w;
      par = el && _par(el);
      root = _docNode(el);
      el_rect = _rect(el);
      root_rect = _rect(root);
      root_scroll = _get_doc_scroll(root);
      doc_rect = docRect(el);
      clip_rect = {
        t: 0,
        l: 0,
        r: 0,
        b: 0,
        w: 0,
        h: 0
      };
      exp_rect = {
        t: 0,
        l: 0,
        r: 0,
        b: 0,
        xs: 0,
        ys: 0,
        xiv: 0,
        yiv: 0,
        iv: 0,
        w: 0,
        h: 0
      };
      xsb_h = 0;
      ysb_w = 0;
      is_scroll_node = false;
      is_using_doc_root_r = false;
      is_using_doc_root_b = false;
      cur_st = void 0;
      w = void 0;
      h = void 0;
      t = void 0;
      l = void 0;
      r = void 0;
      b = void 0;
      scroll_width = void 0;
      offset_width = void 0;
      client_width = void 0;
      scroll_height = void 0;
      offset_height = void 0;
      client_height = void 0;
      over_x_val = void 0;
      scroll_left = void 0;
      scroll_top = void 0;
      over_y_val = void 0;
      clip = void 0;
      x_hidden = void 0;
      y_hidden = void 0;
      ref_node = void 0;
      temp_rect = void 0;
      is_scroll_node = false;
      details = (details && typeof details === OBJ ? details : {});
      if (par) {
        while (cur_st = currentStyle(par)) {
          if (cur_st["display"] === "block" || cur_st["position"] === "absolute" || cur_st["float"] !== "none" || cur_st["clear"] !== "none") {
            over_x_val = cur_st[OVER + "X"];
            over_y_val = cur_st[OVER + "Y"];
            clip = _getClip(cur_st);
            if (par === root) {
              scroll_width = root_scroll.w;
              scroll_height = root_scroll.h;
            } else {
              scroll_width = par.scrollWidth;
              scroll_height = par.scrollHeight;
            }
            offset_width = par.offsetWidth;
            offset_height = par.offsetHeight;
            client_width = par.clientWidth;
            client_height = par.clientHeight;
            if (over_x_val === HIDDEN || clip[1] > 0 || clip[3] > 0) {
              if (!ref_node) {
                x_hidden = 1;
                ref_node = par;
              }
            }
            if (over_y_val === HIDDEN || clip[0] > 0 || clip[2] > 0) {
              if (!ref_node) {
                y_hidden = 1;
                ref_node = par;
              }
            }
            if (over_x_val === SCROLL) {
              ref_node = par;
              xsb_h = offset_height - client_height;
              is_scroll_node = true;
            }
            if (over_y_val === SCROLL) {
              if (!ref_node) {
                ref_node = par;
              }
              ysb_w = offset_width - client_width;
              is_scroll_node = true;
            }
            if (over_x_val === AUTO) {
              if (!ref_node) {
                ref_node = par;
              }
              if (scroll_width > client_width) {
                xsb_h = offset_height - client_height;
              }
              is_scroll_node = true;
            }
            if (over_y_val === AUTO) {
              if (!ref_node) {
                ref_node = par;
              }
              if (scroll_height > client_height) {
                ysb_w = offset_width - client_width;
              }
              is_scroll_node = true;
            }
            if (ref_node) {
              break;
            }
          }
          if (par === root) {
            if (scroll_width > client_width) {
              h = (win.innerHeight || 0) || offset_height;
              xsb_h = h - client_height;
            }
            if (scroll_height > client_height) {
              w = (win.innerWidth || 0) || offset_width;
              ysb_w = w - client_width;
            }
            is_scroll_node = true;
          }
          par = _par(par);
          if (!par || par[NODE_TYPE] !== 1) {
            break;
          }
        }
      }
      if (el_rect.w && el_rect.h) {
        if (!ref_node || ref_node === root) {
          exp_rect.t = _max(el_rect.t, 0);
          exp_rect.l = _max(el_rect.l, 0);
          if (ieVer && dc[COMPAT_MODE] === "BackCompat" && _attr(root, SCROLL) === "no") {
            y_hidden = x_hidden = 1;
          } else {
            cur_st = currentStyle(root);
            if (cur_st) {
              x_hidden = cur_st[OVER + "X"] === HIDDEN;
              y_hidden = cur_st[OVER + "Y"] === HIDDEN;
            }
          }
          if (root_scroll.h > root.clientHeight) {
            if (y_hidden) {
              exp_rect.b = 0;
            } else {
              is_using_doc_root_b = true;
              exp_rect.b = _max(((doc_rect.h - el_rect.h) - xsb_h) - el_rect.t, 0);
            }
          } else {
            exp_rect.b = _max(((root_rect.h - el_rect.h) - xsb_h) - el_rect.t, 0);
          }
          if (root_scroll.w > root.clientWidth) {
            if (x_hidden) {
              exp_rect.r = 0;
            } else {
              is_using_doc_root_r = true;
              exp_rect.r = _max(((doc_rect.w - el_rect.w) - ysb_w) - el_rect.l, 0);
            }
          } else {
            exp_rect.r = _max(((root_rect.r - el_rect.w) - ysb_w) - el_rect.l, 0);
          }
        } else {
          cur_st = currentStyle(ref_node);
          if (_tagName(ref_node) === "body") {
            ref_node = root;
            t = el_rect.t;
            l = el_rect.l;
          } else {
            t = l = 0;
          }
          clip_rect = _rect(ref_node);
          if (clip[1] > 0) {
            clip_rect.w = clip[1];
            clip_rect.r = clip_rect.l + clip_rect.w;
          }
          if (clip[3] > 0) {
            clip_rect.l = clip_rect.l + clip[3];
            clip_rect.w = clip_rect.w - clip[3];
          }
          if (clip[2] > 0) {
            clip_rect.h = clip[2];
            clip_rect.b = clip_rect.t + clip_rect.h;
          }
          if (clip[0] > 0) {
            clip_rect.t = clip_rect.t + clip[0];
            clip_rect.h = clip_rect.h - clip[0];
          }
          if (el_rect.t > clip_rect.t && clip_rect.t > 0) {
            t = el_rect.t - clip_rect.t;
          }
          if (el_rect.l > clip_rect.l && clip_rect.l > 0) {
            l = el_rect.l - clip_rect.l;
          }
          scroll_top = ref_node.scrollTop;
          scroll_left = ref_node.scrollLeft;
          scroll_height = ref_node.scrollHeight;
          scroll_width = ref_node.scrollWidth;
          exp_rect.t = _max(t, 0);
          exp_rect.l = _max(l, 0);
          if (cur_st) {
            x_hidden = cur_st[OVER + "X"] === HIDDEN || clip[1] > 0 || clip[3] > 0;
            y_hidden = cur_st[OVER + "Y"] === HIDDEN || clip[0] > 0 || clip[2] > 0;
          }
          if (el_rect.t >= clip_rect.b) {
            exp_rect.b = 0;
          } else {
            if (!y_hidden && el_rect.t >= clip_rect.b) {
              y_hidden = 1;
            }
            if (scroll_height > ref_node.clientHeight) {
              if (y_hidden) {
                exp_rect.b = 0;
              } else {
                exp_rect.b = _max(((scroll_height - el_rect.h) - xsb_h) - t, 0);
              }
            } else {
              exp_rect.b = _max(((clip_rect.h - el_rect.h) - xsb_h) - t, 0);
            }
          }
          if (el_rect.l >= clip_rect.r) {
            exp_rect.r = 0;
          } else {
            if (!x_hidden && el_rect.l >= clip_rect.r) {
              x_hidden = 1;
            }
            if (scroll_width > ref_node.clientWidth) {
              if (x_hidden) {
                exp_rect.r = 0;
              } else {
                exp_rect.r = _max(((scroll_width - el_rect.w) - ysb_w) - l, 0);
              }
            } else {
              exp_rect.r = _max(((clip_rect.w - el_rect.w) - ysb_w) - l, 0);
            }
          }
        }
        exp_rect.xs = (xsb_h ? 1 : 0);
        exp_rect.ys = (ysb_w ? 1 : 0);
        exp_rect.w = exp_rect.r + exp_rect.l;
        exp_rect.h = exp_rect.t + exp_rect.b;
        if (!ref_node || ref_node === root) {
          temp_rect = root_rect;
          ref_node = root;
        } else {
          temp_rect = clip_rect;
        }
        l = _max(el_rect.l, temp_rect.l);
        r = _min(el_rect.r, (is_using_doc_root_r ? _min(doc_rect.r, temp_rect.r) : temp_rect.r));
        w = _max(r - l, 0);
        t = _max(el_rect.t, temp_rect.t);
        b = _min(el_rect.b, (is_using_doc_root_b ? _min(doc_rect.b, temp_rect.b) : temp_rect.b));
        h = _max(b - t, 0);
        exp_rect.xiv = _cnum((w / el_rect.w)[TFXD](2));
        exp_rect.yiv = _cnum((h / el_rect.h)[TFXD](2));
        exp_rect.iv = _cnum(((w * h) / (el_rect.w * el_rect.h))[TFXD](2));
      }
      details.refNode = ref_node || root;
      details.isRoot = ref_node === root;
      details.canScroll = is_scroll_node;
      details.refRect = (!ref_node || ref_node === root ? root_rect : clip_rect);
      details.expRect = exp_rect;
      details.rect = el_rect;
      if (check_3D) {
        (function() {
          var arOvrlaps, el_area, el_h, el_w, idx, len, new_iv, new_xiv, new_yiv, ovr_area, ovr_node, ovr_node_rect;
          idx = 0;
          len = 0;
          arOvrlaps = void 0;
          el_w = void 0;
          el_h = void 0;
          el_area = void 0;
          ovr_node = void 0;
          ovr_node_rect = void 0;
          t = void 0;
          b = void 0;
          l = void 0;
          r = void 0;
          h = void 0;
          w = void 0;
          ovr_area = void 0;
          new_iv = void 0;
          new_xiv = void 0;
          new_yiv = void 0;
          if (exp_rect.iv > .5) {
            mgr_bounds_details = details;
            arOvrlaps = overlaps(el, _cnum(check_3D, 1, 1));
            mgr_bounds_details = null;
            len = arOvrlaps[LEN];
            el_w = el_rect.w;
            el_h = el_rect.h;
            el_area = el_w * el_h;
            if (len) {
              while (ovr_node = arOvrlaps[idx++]) {
                ovr_node_rect = _rect(ovr_node);
                l = _max(el_rect.l, ovr_node_rect.l);
                r = _min(el_rect.r, ovr_node_rect.r);
                t = _max(el_rect.t, ovr_node_rect.t);
                b = _min(el_rect.b, ovr_node_rect.b);
                w = r - l;
                h = b - t;
                ovr_area = w * h;
                new_xiv = (1 - (w / el_w))[TFXD](2);
                new_yiv = (1 - (h / el_h))[TFXD](2);
                new_iv = (1 - (ovr_area / el_area))[TFXD](2);
                if ((new_xiv > 0 && new_xiv < exp_rect.xiv) || (new_yiv > 0 && new_yiv < exp_rect.yiv)) {
                  exp_rect.xiv = new_xiv;
                  exp_rect.yiv = new_yiv;
                  exp_rect.iv = new_iv;
                }
              }
            }
          }
        })();
      }
      return exp_rect;
    };

    /*
    Find any HTMLElements that are covering a given HTMLElement.
    
    @name $sf.lib.dom.overlaps
    @public
    @static
    @function
    @param {HTMLElement} el The HTMLElement for which to find any other elements that may be covering it.
    @param {Number} [limit] The maximum number of covering elements to return
    @returns {Array} An array of elements that are covering the given element
     */
    overlaps = function(el, limit) {
      var baseH, baseW, checkEl, curH, curW, doc, factor, h, id, idx, l, maxX, maxY, par_details, points, pt, rect, ref_par_node, ref_par_rect, ret, root, seen, t, w, x, y;
      rect = _rect(el);
      doc = _doc(el);
      root = _docNode(doc);
      t = rect.t;
      l = rect.l;
      w = rect.r - rect.l;
      h = rect.b - rect.t;
      factor = INTERSECT_FACTOR;
      ret = [];
      baseW = _round(w / factor);
      baseH = _round(h / factor);
      curW = baseW;
      curH = baseH;
      seen = {};
      par_details = {};
      points = [];
      idx = 0;
      x = void 0;
      y = void 0;
      pt = void 0;
      id = void 0;
      checkEl = void 0;
      ref_par_node = void 0;
      ref_par_rect = void 0;
      maxX = void 0;
      maxY = void 0;
      if (mgr_bounds_details) {
        par_details = mgr_bounds_details;
      } else {
        bounds(el, par_details, true);
      }
      ref_par_node = par_details.refNode;
      ref_par_rect = par_details.refRect;
      if (ref_par_rect && ref_par_node && ref_par_node !== root) {
        maxX = ref_par_rect.r;
        maxY = ref_par_rect.b;
      } else {
        maxX = l + w;
        maxY = t + h;
      }
      if (doc && root && doc[EL_FROM_PT]) {
        while (curW < w) {
          curH = baseH;
          while (curH < h) {
            x = l + curW;
            y = t + curH;
            if (x < maxX && y < maxY) {
              points.push([x, y]);
            }
            curH += baseH;
          }
          curW += baseW;
        }
        limit = _cnum(limit, points[LEN]);
        while (pt = points[idx++]) {
          checkEl = doc[EL_FROM_PT](pt[0], pt[1]);
          try {
            if (checkEl && checkEl.nodeType === 1 && checkEl !== root && checkEl !== el && !contains(el, checkEl)) {
              id = _attr(checkEl, "id");
              if (!id) {
                id = lang.guid("geom_inter");
                _attr(checkEl, "id", id);
              }
              if (!seen[id] && ret[LEN] < limit) {
                seen[id] = 1;
                ret.push(checkEl);
              }
            }
          } catch (_error) {}
        }
      }
      id = "";
      for (id in seen) {
        if (id.indexOf("geom_inter") === 0) {
          checkEl = _elt(id);
          if (checkEl) {
            _attr(checkEl, "id", null);
          }
        }
      }
      return ret;
    };

    /*
    A proxy wrapper for calling into the cross-domain messaging host fall back library
    Looks for namespace will be $sf.lib.dom.msghost_fb
    Said library is used in cases where there is not HTML5 style messaging (i.e. no postMessage method available).
    
    @name $sf.lib.dom.msghost-_call_xmsg_host_fb
    @private
    @static
    @function
    @param {String} methName The method name in the msg host library to call
    @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
    @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
    @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
    @returns {*} whatever comes back from the method
     */
    _call_xmsg_host_fb = function(methName, arg1, arg2, arg3) {
      if (!msghostfb) {
        msghostfb = dom.msghost_fb;
      }
      return methName && msghostfb && msghostfb[methName] && msghostfb[methName](arg1, arg2, arg3);
    };

    /*
    Listen for an initial HTML5 postMessage event, to validate that HTML5 style
    messaging can be used
    
    @name $sf.lib.dom.msghost-_check_html5_init
    @private
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event object received from the postMessage call
     */
    _check_html5_init = function(evt) {
      if (!canUseHTML5 && evt && evt.data === initID) {
        canUseHTML5 = true;
        dom.evtCncl(evt);
        dom[DETACH](win, MSG, _check_html5_init);
      }
    };

    /*
    Listen for onmessage events in the main window. Validate that message is for us, and if so
    pass it through to the rest of the code and cancel further handling.
    
    @name $sf.lib.dom.msghost-_handle_msg_from_outside
    @private
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event object received from the postMessage call
     */
    _handle_msg_from_outside = function(evt) {
      var cb, data, dataGUID, e, fr_win, ifr, msg_win, params, pipe, pipeGUID, ret, tgtID;
      data = evt && evt.data;
      msg_win = evt && evt.source;
      params = data && (data.indexOf(GUID) !== -1) && ParamHash(data);
      tgtID = params && params.id;
      ifr = tgtID && _elt(tgtID);
      fr_win = ifr && _ifr_view(ifr);
      pipe = tgtID && msg_pipes[tgtID];
      dataGUID = params && params[GUID];
      pipeGUID = pipe && pipe[GUID];
      cb = pipe && pipe._xmsgcb;
      ret = false;
      if (pipeGUID && dataGUID && dataGUID === pipeGUID && msg_win && fr_win && fr_win === msg_win) {
        try {
          ret = cb(params.msg);
        } catch (_error) {
          e = _error;
          ret = false;
        }
      }
      if (ret) {
        dom.evtCncl(evt);
      }
      return ret;
    };

    /*
    Send a message to a child iframe.
    
    @name $sf.lib.dom.msghost.send
    @public
    @static
    @function
    @param {String} tgtID The HTML id attribute of the iframe element for which to send a message
    @param {String} data The string of data to send to the given iframe
    @returns {Boolean} Whether or not message was send succesfully (note that this does not mean message was handled / recevied, only that sending was ok).
     */
    send_msg_to_child_iframe = function(tgtID, data) {
      var e, el, msgObj, pipe, success, w;
      pipe = tgtID && msg_pipes[tgtID];
      success = false;
      msgObj = void 0;
      w = void 0;
      el = void 0;
      e = void 0;
      if (!pipe) {
        success = _call_xmsg_host_fb("send", tgtID, data);
      } else {
        if (pipe) {
          msgObj = ParamHash();
          msgObj.msg = data;
          msgObj.guid = pipe.guid;
          if (usingHTML5()) {
            el = _elt(tgtID);
            w = _ifr_view(el);
            try {
              w[PMSG](_cstr(msgObj), pipe.srcHost || "*");
              success = true;
            } catch (_error) {
              e = _error;
              success = false;
            }
          } else {
            success = _call_xmsg_host_fb("send", tgtID, data);
          }
        }
      }
      msgObj = w = el = null;
      return success;
    };

    /*
    Get whether or not HTML5 style messaging can be used
    
    @name $sf.lib.dom.msghost.usingHTML5
    @public
    @static
    @function
    @returns {Boolean}
     */
    usingHTML5 = function() {
      return canUseHTML5;
    };

    /*
    Gets a location of the hosting page, stripped of the search hash,
    but leaving query parameters, port, host, path, etc.
     */
    _strippedEncodedLocation = function() {
      var cleaned, pos;
      cleaned = void 0;
      pos = loc.href.indexOf("#");
      if (pos > -1) {
        cleaned = loc.href.substr(0, pos);
      } else {
        cleaned = loc.href;
      }
      pos = cleaned.indexOf("?");
      if (pos > -1) {
        cleaned = cleaned.substr(0, pos);
      }
      return escape(cleaned);
    };

    /*
    Prepare an iframe in the top level window to be able to send / receive cross-domain messages
    Generally this method is called from $sf.lib.iframes.  The attrs object in question should
    represent key/value pairs of HTML attributes for the iframe. Note that the attrs object passed
    in will be modified with a new "name" property, to send information into the iframe and setup
    messaging.
    
    @name $sf.lib.dom.msghost.prep
    @public
    @static
    @function
    @param {Object} attrs Information required to set up the cross-domain messaging channel
    @param {String} attrs.id The IFRAME HTML id attribute
    @param {String} attrs.src The URL / src attribute of the IFRAME
    @param {String} [attrs.guid] The guid / signature to use to validate that messages sent/ received can be accepted. If not specified, one will be created automatically.
    @param {String} [attrs.name] The IFRAME HTML name attribute which will be used to send an intial message to the HTML document inside the IFRAME.
    @returns {Object} An object with various properties detailing the messaging pipe-line.
     */
    prep_iframe_msging = function(attrs) {
      var iframeName, locStripped, nameParams, newPipe, pipe, src, srcHost;
      pipe = null;
      iframeName = void 0;
      nameParams = void 0;
      src = void 0;
      srcHost = void 0;
      newPipe = void 0;
      locStripped = _strippedEncodedLocation();
      if (attrs) {
        iframeName = attrs.name;
        nameParams = ParamHash(iframeName);
        src = _cstr(attrs.src);
        srcHost = src && src.substring(0, src.indexOf("/", 9));
        srcHost = (srcHost.search(/http/g) !== 0 ? "" : srcHost);
        pipe = ParamHash(nameParams);
        pipe.id = attrs.id || ("iframe_" + _guid());
        pipe.src = src;
        pipe.srcHost = srcHost;
        pipe[GUID] = pipe[GUID] || _guid();
        pipe.host = locHost;
        pipe.loc = locStripped;
        pipe.proxyID = "";
        if (usingHTML5()) {
          pipe.html5 = 1;
          pipe.proxyPath = "";
        } else {
          newPipe = _call_xmsg_host_fb("prep", pipe);
          if (newPipe) {
            pipe = newPipe;
          }
        }
        attrs.name = pipe;
      }
      return pipe;
    };

    /*
    Listen for messages from an IFRAME. Note that on the host / publisher side
    this library only allows for one message handler to be attached to a given
    IFRAME.
    
    @name $sf.lib.dom.msghost.attach
    @public
    @static
    @function
    @param {HTMLElement} el The IFRAME reference to attach a listener callback too. .
    @param {Object} pipe The message pipe object created from $sf.lib.dom.msghost.prep
    @param {Function} cb The callback function to fire when a message is received
     */
    attach_iframe_msging = function(el, pipe, cb) {
      var tgtID;
      tgtID = void 0;
      if (_tagName(el) === "iframe") {
        tgtID = _attr(el, "id");
        if (tgtID && pipe && (pipe instanceof ParamHash) && tgtID === pipe.id) {
          if (usingHTML5()) {
            msg_pipes[tgtID] = pipe;
            pipe._xmsgcb = cb;
            if (!html5Bound) {
              dom[ATTACH](win, MSG, _handle_msg_from_outside);
              html5Bound = true;
            }
          } else {
            _call_xmsg_host_fb(ATTACH, el, pipe, cb);
          }
        }
      }
    };

    /*
    Detach listening for messages from an IFRAME
    
    @name $sf.lib.dom.msghost.detach
    @public
    @static
    @function
    @param {HTMLElement} el The IFRAME reference to detach a listener
     */
    detach_iframe_msging = function(el) {
      var empty, id, pipe, w;
      id = _attr(el, "id");
      pipe = id && msg_pipes[id];
      w = null;
      empty = true;
      if (!pipe) {
        _call_xmsg_host_fb(DETACH, el);
        return;
      }
      if (pipe) {
        pipe._xmsgcb = msg_pipes[id] = null;
        pipe = null;
        delete msg_pipes[id];
      }
      id = "";
      for (id in msg_pipes) {
        pipe = msg_pipes[id];
        if (pipe && pipe[GUID]) {
          empty = false;
          break;
        }
      }
      if (empty && usingHTML5() && html5Bound) {
        html5Bound = false;
        dom[DETACH](win, MSG, _handle_msg_from_outside);
      }
      el = w = pipe = null;
    };

    /*
    Fire the specifed callback out to the publisher. Note that other arguments beyond the 1st argument are passed throug to the callback.
    
    @name $sf.host-_fire_pub_callback
    @static
    @private
    @function
    @param {String} cb_name The callback name to fire
     */
    _fire_pub_callback = function(cb_name) {
      var a, args, cb_args, e, f, idx, len, ret;
      cb_args = [];
      args = arguments;
      len = args[LEN];
      idx = 0;
      f = void 0;
      ret = false;
      e = void 0;
      a = void 0;
      if (config) {
        f = config[cb_name];
        if (f) {
          while (len--) {
            a = args[idx++];
            if (a !== cb_name) {
              cb_args.push(a);
            }
          }
          try {
            ret = f.apply(null, cb_args);
          } catch (_error) {
            e = _error;
            ret = false;
          }
        }
      }
      return ret;
    };

    /*
    Nuke the position an report that said position took too long to render
    
    @name $sf.host-_handle_render_timeout
    @static
    @private
    @function
    @param {String} pos_id The position id that has taken too long
     */
    _handle_render_timeout = function(pos_id) {
      var pend;
      pend = pos_id && pending_ifrs[pos_id];
      if (pend) {
        clearTimeout(pend);
        nuke(pos_id);
        _fire_pub_callback(POS_MSG, "render-timeout", pos_id);
      }
      if (!_has_pending_renders()) {
        current_status = "";
      }
    };

    /*
    Clear the timer that fires every so often to update the geometry in side
    of SafeFrames
    
    @name $sf.host-_clear_geom_update_timer
    @static
    @private
    @function
     */
    _clear_geom_update_timer = function() {
      if (geom_update_timer) {
        clearTimeout(geom_update_timer);
        geom_update_timer = 0;
      }
    };

    /*
    +	 * Clear the timer that fires every so often to update the geometry in side
    +	 * of SafeFrames
    +	 *
    +	 * @name $sf.host-_clear_geom_update_timer
    +	 * @static
    +	 * @private
    +	 * @function
    +	 *
    +
     */
    _clear_focus_update_timer = function() {
      if (focus_update_timer) {
        clearTimeout(focus_update_timer);
        focus_update_timer = 0;
      }
    };
    _set_focus_update_timer = function(in_focus) {
      _clear_focus_update_timer();
      focus_update_timer = setTimeout(function() {
        _update_focus(in_focus);
      }, 2);
    };

    /*
    Set up the timer function that updates each SafeFrame with up to date geometric information
    
    @name $sf.host-_set_geom_update_timer
    @static
    @private
    @function
     */
    _set_geom_update_timer = function(is_win_scroll) {
      _clear_geom_update_timer();
      if (is_win_scroll) {
        geom_update_timer = setTimeout(_update_geom_win_scroll, GEOM_UPDATE_INTRVAL);
      } else {
        geom_update_timer = setTimeout(_update_geom_win_resize, GEOM_UPDATE_INTRVAL);
      }
    };

    /*
    Update all SafeFrames with updated geometric information
    
    @name $sf.host-_update_geom
    @static
    @private
    @function
    @param {Boolean} is_win_scroll Whether or not we are updating due to the main window being scrolled
     */
    _update_geom = function(is_win_scroll) {
      var g, id, ifr, msgObj, params, posID;
      posID = void 0;
      params = void 0;
      msgObj = void 0;
      id = void 0;
      ifr = void 0;
      g = void 0;
      for (posID in rendered_ifrs) {
        if (is_win_scroll && (posID in scroll_parents_attached)) {
          continue;
        }
        params = rendered_ifrs[posID];
        id = params && params.dest;
        ifr = id && _elt(id);
        if (ifr && params) {
          g = _build_geom(posID, ifr, true);
          msgObj = ParamHash();
          msgObj.pos = posID;
          msgObj.cmd = NOTIFY_GEOM_UPDATE;
          msgObj.geom = _es(g);
          _fire_pub_callback(POS_MSG, posID, NOTIFY_GEOM_UPDATE, g);
          _send_response(params, msgObj);
        }
      }
      _clear_geom_update_timer();
    };

    /*
    Update all SafeFrames with updated geometric information due to a window resize
    event.
    
    @name $sf.host-_update_geom_win_resize
    @static
    @private
    @function
     */
    _update_geom_win_resize = function() {
      _update_geom();
    };

    /*
    Update all SafeFrames with updated geometric information due to a window scroll event
    
    @name $sf.host-_update_geom_win_scroll
    @static
    @private
    @function
     */
    _update_geom_win_scroll = function() {
      _update_geom(true);
    };

    /*
    Update a SafeFrame that has new geometric information due to its parent HTML element
    scrolling.
    
    @name $sf.host-_handle_node_scroll
    @static
    @private
    @function
     */
    _handle_node_scroll = function(evt, posID, node) {
      var g, scr_handle;
      scr_handle = scroll_parents_attached[posID];
      g = void 0;
      if (scr_handle) {
        if (scr_handle.tID) {
          clearTimeout(scr_handle.tID);
          delete scr_handle.tID;
        }
        scr_handle.tID = setTimeout(function() {
          var id, ifr, msgObj, params;
          params = rendered_ifrs[posID];
          id = params && params.dest;
          ifr = id && _elt(id);
          g = void 0;
          msgObj = void 0;
          if (ifr && params) {
            g = _build_geom(posID, ifr, true);
            msgObj = ParamHash();
            msgObj.pos = posID;
            msgObj.cmd = NOTIFY_GEOM_UPDATE;
            msgObj.geom = _es(g);
            _fire_pub_callback(POS_MSG, posID, NOTIFY_GEOM_UPDATE, g);
            _send_response(params, msgObj);
          }
          delete scr_handle.tID;
        }, GEOM_UPDATE_INTRVAL);
      }
    };

    /*
    Handle the window onscroll event, eventually leading to a geometric update
    
    @name $sf.host-_handle_win_geom_scroll
    @static
    @private
    @function
    @param {HTMLEvent} evt The raw event object
     */
    _handle_win_geom_scroll = function(evt) {
      _set_geom_update_timer(1);
    };

    /*
    Handle the window onresize event, eventually leading to a geometric update
    once the window events are slowed down
    
    @name $sf.host-_handle_win_geom_resize
    @static
    @private
    @function
    @param {HTMLEvent} evt The raw event object
     */
    _handle_win_geom_resize = function(evt) {
      _set_geom_update_timer();
    };

    /*
    Update all SafeFrames with updated focus information
    
    @name $sf.host-_update_focus
    @static
    @private
    @function
    @param {Boolean} in_focus True when the window has gained focus
     */
    _update_focus = function(in_focus) {
      var data, id, ifr, msgObj, params, posID;
      posID = void 0;
      params = void 0;
      msgObj = void 0;
      id = void 0;
      ifr = void 0;
      for (posID in rendered_ifrs) {
        params = rendered_ifrs[posID];
        id = params && params.dest;
        ifr = id && _elt(id);
        if (ifr && params) {
          msgObj = ParamHash();
          data = ParamHash();
          msgObj.pos = posID;
          msgObj.cmd = data.cmd = NOTIFY_FOCUS_CHANGE;
          msgObj.value = in_focus;
          _fire_pub_callback(POS_MSG, posID, NOTIFY_FOCUS_CHANGE, in_focus);
          _send_response(params, msgObj);
        }
      }
      _clear_focus_update_timer();
    };

    /*
    Handle the window focus event, which notifies ads of the change
     */
    _handle_win_focus = function(evt) {
      _set_focus_update_timer(true);
    };

    /*
    Handle the window blur event, which notifies ads of the change
     */
    _handle_win_blur = function(evt) {
      _set_focus_update_timer(false);
    };

    /*
    Handle the window unload event, clearing up our state
    
    @name $sf.host-_handle_unload
    @static
    @private
    @function
    @param {HTMLEvent} evt The raw event object
     */
    _handle_unload = function(evt) {
      var e, prop, scr_handle;
      prop = void 0;
      scr_handle = void 0;
      e = void 0;
      _clear_geom_update_timer();
      try {
        dom.detach(win, SCROLL, _handle_win_geom_scroll);
        dom.detach(win, "resize", _handle_win_geom_resize);
        dom.detach(win, "unload", _handle_unload);
        dom.detach(win, "focus", _handle_win_focus);
        dom.detach(win, "blur", _handle_win_blur);
        for (prop in scroll_parents_attached) {
          scr_handle = scroll_parents_attached[prop];
          if (scr_handle) {
            if (scr_handle.tID) {
              clearTimeout(scr_handle.tID);
            }
            dom.detach(scroll_parents_attached[prop], SCROLL, scr_handle[ONSCROLL]);
            scr_handle[ONSCROLL] = scr_handle.node = null;
          }
          scroll_parents_attached[prop] = null;
          delete scroll_parents_attached[prop];
        }
        win_events_attached = false;
      } catch (_error) {}
    };

    /*
    Handle the window message event, passed from raw event handling of the msghost code.
    Pass through the data to our format handling functions for expand, etc.
    
    @name $sf.host-_handle_msg_evt
    @static
    @private
    @function
    @param {String|Object} data the message to be handled
    @return {Boolean} return whether or not the message was handled
     */
    _handle_msg_evt = function(data) {
      var canRead, canWrite, info, msgObj, ret;
      msgObj = void 0;
      ret = false;
      info = void 0;
      msgObj = ParamHash(data, null, null, true, true);
      if (msgObj && msgObj.pos) {
        info = rendered_ifrs[msgObj.pos];
        if (info) {
          ret = (function() {
            switch (msgObj.cmd) {
              case "exp-push":
                _expand_safeframe(msgObj, true);
                return true;
              case "exp-ovr":
                _expand_safeframe(msgObj);
                return true;
              case "collapse":
                _collapse_safeframe(msgObj);
                return true;
              case "msg":
                _fire_pub_callback(POS_MSG, msgObj.pos, "msg", msgObj.msg);
                return true;
              case ERROR_COMMAND:
                _record_error(msgObj);
                return true;
              case NOTIFY_GEOM_UPDATE:
                sf.lib.logger.log("Geom update complete: " + msgObj.pos);
                return true;
              case "read-cookie":
                canRead = info.conf && info.conf.supports && info.conf.supports[msgObj.cmd] && info.conf.supports[msgObj.cmd] !== "0";
                if (canRead) {
                  _read_cookie(msgObj);
                  return true;
                } else {
                  return false;
                }
                break;
              case "write-cookie":
                canWrite = info.conf && info.conf.supports && info.conf.supports[msgObj.cmd] && info.conf.supports[msgObj.cmd] !== "0";
                if (canWrite) {
                  _write_cookie(msgObj);
                  return true;
                } else {
                  return false;
                }
            }
          })();
        }
      }
      return ret;
    };

    /*
    Check whether or not there are any SafeFrames being rendered
    
    @name $sf.host-_has_pending_renders
    @static
    @private
    @function
     */
    _has_pending_renders = function() {
      var all_renders_done, pos_id;
      all_renders_done = true;
      pos_id = void 0;
      for (pos_id in pending_ifrs) {
        all_renders_done = false;
        break;
      }
      return all_renders_done;
    };

    /*
    Send a response back down to the SafeFrame after a message was handled
    
    @name $sf.host-_send_response
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} params The parameters object stored for a rendered SafeFrame holding state information
    @param {$sf.lib.lang.ParamHash} msgObj The message to send back down into the SafeFrame
     */
    _send_response = function(params, msgObj) {

      /*
      @ignore
       */
      current_status = "sending-msg-down-" + msgObj.cmd;
      setTimeout((function() {
        var id;
        id = params && params.dest;
        if (id && msgObj) {
          send_msg_to_child_iframe(id, msgObj.toString());
        }
        current_status = "";
        msgObj = id = params = null;
      }), XCOM_RESP_DELAY);
    };

    /*
    Handle the onload event from the IFRAME tag created for a SafeFrame.
    Note that b/c we used our own library to create the IFRAME ($sf.lib.dom.iframes),
    the "this" keyword will now properly point to the IFRAME in question.
    
    @name $sf.host-_handle_frame_load
    @private
    @static
    @function
     */
    _handle_frame_load = function() {
      var all_renders_done, el, pos_id;
      el = this;
      pos_id = dom.attr(el, "_pos_id");
      all_renders_done = true;
      if (pending_ifrs[pos_id]) {
        clearTimeout(pending_ifrs[pos_id]);
        delete pending_ifrs[pos_id];
        complete_ifrs[pos_id] = pos_id;
        dom.attr(el, "_pos_id", null);
        dom.attr(el, "name", null);
        el[ST].visibility = "inherit";
        el[ST].display = "block";
        _fire_pub_callback("onEndPosRender", pos_id);
      }
      if (!_has_pending_renders()) {
        current_status = "";
      }
    };

    /*
    Build an extra IFRAME to put behind any iframe that is expanding, to protect
    against painting issues in IE with window'd mode flash.
    
    @name $sf.host-_shim_frame
    @private
    @static
    @function
     */
    _shim_frame = function(id, showIt, w, h, z) {
      var ifr, shmFrm, shmID;
      if (!isIE) {
        return;
      }
      ifr = _elt(id);
      shmID = "shm_" + id;
      shmFrm = _elt(shmID);
      if (showIt) {
        if (shmFrm) {
          shmFrm[ST].visibility = "visible";
          return;
        }
        shmFrm = iframes.clone(ifr, {
          id: shmID,
          src: "",
          name: shmID
        }, [WIDTH, ":", w, PX, ";position:absolute;", HEIGHT, ":", h, PX, ";z-index:", z - 1, ";filter:progid:DXImageTransform.Microsoft.Alpha(opacity=0)"]);
        dom.append(_par(ifr), shmFrm);
      } else {
        if (!showIt && shmFrm) {
          shmFrm[ST].visibility = "hidden";
        }
      }
    };

    /*
    Build a geometry info object for a particular SafeFrame position, and also
    may attach an onscroll event listener to a parent HTML element if said parent element
    is scrollable but not the root document node / body
    
    @name $sf.host-_build_geom
    @private
    @static
    @function
    @return {Object} With information about the geometry around a given SafeFrame
     */
    _build_geom = function(posID, dest, dont_attach_scroll_evt) {
      var details, e, ex, info, new_ref_node, node, s, scr_handle;
      bounds = void 0;
      info = ParamHash();
      details = {};
      scr_handle = void 0;
      node = void 0;
      new_ref_node = void 0;
      ex = void 0;
      s = void 0;
      e = void 0;
      try {
        bounds = dom.bounds(dest, details, true);
        if (!dont_attach_scroll_evt && !details.isRoot && details.canScroll) {
          ex = details.expRect;
          if (ex.xs || ex.ys) {
            scr_handle = scroll_parents_attached[posID];
            new_ref_node = details.refNode;
            if (scr_handle && scr_handle.node !== new_ref_node) {
              if (scr_handle.tID) {
                clearTimeout(scr_handle.tID);
              }
              dom.detach(node, SCROLL, scr_handle[ONSCROLL]);
              scr_handle.node = scr_handle[ONSCROLL] = null;
              scroll_parents_attached[posID] = null;
              delete scroll_parents_attached[posID];
            }
            if (!scroll_parents_attached[posID]) {
              scr_handle = {};
              scr_handle.node = new_ref_node;

              /*
              @ignore
               */
              scr_handle[ONSCROLL] = function(evt) {
                _handle_node_scroll(evt, posID);
              };
              scroll_parents_attached[posID] = scr_handle;
              dom.attach(new_ref_node, SCROLL, scr_handle[ONSCROLL]);
            }
          }
        }
      } catch (_error) {
        e = _error;
        info = null;
      }
      try {
        if (info) {
          info.win = ParamHash(dom.winRect());
          info.par = ParamHash(details.refRect);
          ex = ParamHash(details.expRect);
          s = ParamHash(details.rect);
          s.iv = ex.iv;
          s.xiv = ex.xiv;
          s.yiv = ex.yiv;
          delete ex.iv;
          delete ex.xiv;
          delete ex.yiv;
          info.exp = ex;
          info.self = s;
        }
      } catch (_error) {
        e = _error;
        info = null;
      }
      return info;
    };

    /*
    Expands a given SafeFrame based on a command from the 3rd party content
    
    @name $sf.host-_expand_safeframe
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} msgObj Details about how to do the expansion
    
    TODO, handle omni-directional and push
     */
    _expand_safeframe = function(msgObj, push) {
      var b, delta, dx, dy, exp, id, ifr, ifrSt, l, nHt, nWd, orHt, orWd, par, parSt, params, params_conf, posID, r, scr_handle, t, xn, yn, z;
      xn = false;
      yn = false;
      posID = msgObj && msgObj.pos;
      params = void 0;
      params_conf = void 0;
      ifr = void 0;
      par = void 0;
      ifrSt = void 0;
      parSt = void 0;
      orWd = void 0;
      orHt = void 0;
      dx = void 0;
      dy = void 0;
      nWd = void 0;
      nHt = void 0;
      id = void 0;
      t = void 0;
      l = void 0;
      r = void 0;
      b = void 0;
      exp = void 0;
      z = void 0;
      delta = void 0;
      scr_handle = void 0;
      if (!posID) {
        return;
      }
      params = rendered_ifrs[posID];
      params_conf = params && params.conf;
      if (!params || !params_conf) {
        return;
      }
      id = params.dest;
      ifr = _elt(id);
      par = _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
      if (!ifr || !par) {
        return;
      }
      ifrSt = ifr[ST];
      parSt = par[ST];
      if (!ifrSt) {
        return;
      }
      scr_handle = scroll_parents_attached[posID];
      if (scr_handle && scr_handle.tID) {
        clearTimeout(scr_handle.tID);
      }
      _clear_geom_update_timer();
      exp = msgObj.exp_obj;
      orWd = params_conf.w;
      orHt = params_conf.h;
      if (!exp) {
        dx = params.dx = _cnum(msgObj.dx);
        dy = params.dy = _cnum(msgObj.dy);
        xn = dx < 0;
        yn = dy < 0;
        nWd = (xn ? orWd + (dx * -1) : orWd + dx);
        nHt = (yn ? orHt + (dy * -1) : orHt + dy);
      } else {
        t = _cnum(exp.t, 0, 0);
        l = _cnum(exp.l, 0, 0);
        r = _cnum(exp.r, 0, 0);
        b = _cnum(exp.b, 0, 0);
        nWd = _cnum(orWd + l + r, 0, 0);
        nHt = _cnum(orHt + t + b, 0, 0);
        if (t) {
          dy = t * -1;
          yn = true;
        } else {
          dy = 0;
        }
        if (l) {
          dx = l * -1;
          xn = true;
        } else {
          dx = 0;
        }
      }
      if (nWd <= orWd && nHt <= orHt) {
        return;
      }
      if (_fire_pub_callback(BF_POS_MSG, posID, EXPAND_COMMAND, dx, dy)) {
        return;
      }
      ifrSt[WIDTH] = nWd + PX;
      ifrSt[HEIGHT] = nHt + PX;
      if (xn) {
        ifrSt.left = dx + PX;
      }
      if (yn) {
        ifrSt.top = dy + PX;
      }
      z = _cnum(params.z, 0);
      if (!z) {
        z = DEFAULT_ZINDEX;
      }
      ifrSt.zIndex = z;
      _shim_frame(id, true, nWd, nHt, z - 1);
      if (push) {
        parSt[WIDTH] = nWd + PX;
        parSt[HEIGHT] = nHt + PX;
      } else {
        parSt[WIDTH] = orWd + PX;
        parSt[HEIGHT] = orHt + PX;
      }
      params.expanded = true;
      msgObj.dx = dx;
      msgObj.dy = dy;
      msgObj.w = nWd;
      msgObj.h = nHt;
      msgObj.cmd = "expand";
      msgObj.geom = _es(_build_geom(posID, ifr, true));
      _fire_pub_callback(POS_MSG, posID, EXPAND_COMMAND, dx, dy);
      _send_response(params, msgObj);
      ifrSt = par = ifr = params = msgObj = null;
    };

    /*
    Collapse a SafeFrame after it has been expanded
    
    @name $sf.host-_collapse_safeframe
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame to collapse
    @param {Boolean} [isOutside] Whether or not the collapse command came from the publisher
    @param {Boolean} [noMsging] Whether or not to send a message of response back to the SafeFrame being collapsed
     */
    _collapse_safeframe = function(msgObj, isOutside, noMsging) {
      var id, ifr, ifrSt, par, parSt, params, params_conf, posID, scr_handle;
      posID = msgObj && msgObj.pos;
      params = posID && rendered_ifrs[posID];
      params_conf = params && params.conf;
      id = params_conf && params_conf.dest;
      ifr = id && _elt(id);
      par = ifr && _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
      ifrSt = ifr && ifr[ST];
      parSt = par && par[ST];
      scr_handle = void 0;
      if (!posID || !params || !ifr || !par) {
        return;
      }
      if (!params.expanded) {
        return;
      }
      scr_handle = scroll_parents_attached[posID];
      if (scr_handle && scr_handle.tID) {
        clearTimeout(scr_handle.tID);
      }
      _clear_geom_update_timer();
      if (!noMsging) {
        if (_fire_pub_callback(BF_POS_MSG, posID, COLLAPSE_COMMAND, 0, 0)) {
          return;
        }
      }
      ifrSt.left = ifrSt.top = "0px";
      parSt[WIDTH] = ifrSt[WIDTH] = params_conf.w + PX;
      parSt[HEIGHT] = ifrSt[HEIGHT] = params_conf.h + PX;
      ifrSt.zIndex = params.dx = params.dy = 0;
      _shim_frame(id);
      if (!noMsging) {
        _fire_pub_callback(POS_MSG, posID, COLLAPSE_COMMAND, 0, 0);
        msgObj.cmd = (isOutside ? "collapsed" : "collapse");
        msgObj.geom = _es(_build_geom(posID, ifr, true));
        _send_response(params, msgObj);
      }
      ifr = ifrSt = par = parSt = params = msgObj = null;
    };

    /*
    Records a reported error message to $sf.info.errors and fires any listeners
    
    @name $sf.host-_record_error
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame having an error
     */
    _record_error = function(msgObj) {
      var id, ifr, ifrSt, par, parSt, params, params_conf, posID, scr_handle;
      posID = msgObj && msgObj.pos;
      params = posID && rendered_ifrs[posID];
      params_conf = params && params.conf;
      id = params_conf && params_conf.dest;
      ifr = id && _elt(id);
      par = ifr && _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
      ifrSt = ifr && ifr[ST];
      parSt = par && par[ST];
      scr_handle = void 0;
      if (sf && sf.info && sf.info.errs) {
        sf.info.errs.push(msgObj);
      }
      _fire_pub_callback(POS_MSG, posID, ERROR_COMMAND, msgObj);
    };

    /*
    Returns the current document cookies as a hash
    @name $sf.lib._cookieHash
    @private
    @static
    @function
    @returns {Object}
     */
    _cookieHash = function() {
      var c, cookies, cooks, i, key;
      cooks = void 0;
      key = void 0;
      i = void 0;
      cookies = {};
      c = void 0;
      cooks = document.cookie.split("; ");
      i = cooks.length - 1;
      while (i >= 0) {
        c = cooks[i].split("=");
        cookies[c[0]] = c[1];
        i--;
      }
      return cookies;
    };

    /*
    Read a host domain cookie
    
    @name $sf.host-_read_cookie
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame
    @param {Boolean} [isOutside] Whether or not the read-cookie command came from the publisher
     */
    _read_cookie = function(msgObj, isOutside) {
      var canRead, command, cookies, id, ifr, key, params, params_conf, posID;
      posID = msgObj && msgObj.pos;
      params = posID && rendered_ifrs[posID];
      params_conf = params && params.conf;
      id = params_conf && params_conf.dest;
      ifr = id && _elt(id);
      key = void 0;
      cookies = void 0;
      command = "read-cookie";
      canRead = params_conf.supports && params_conf.supports[command] && params_conf.supports[command] !== "0";
      if (!canRead) {
        return;
      }
      if (!posID || !params || !ifr) {
        return;
      }
      key = msgObj.cookie;
      if (!key) {
        return;
      }
      cookies = _cookieHash();
      _fire_pub_callback(POS_MSG, command, posID, 0, 0);
      msgObj.cmd = command;
      msgObj.geom = _es(_build_geom(posID, ifr, true));
      msgObj.value = cookies[key];
      _send_response(params, msgObj);
      ifr = params = msgObj = null;
    };

    /*
    Write a host domain cookie
    
    @name $sf.host-_write_cookie
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame
    @param {Boolean} [isOutside] Whether or not the write-cookie command came from the publisher
     */
    _write_cookie = function(msgObj, isOutside) {
      var c_value, canRead, command, cookies, exdate, id, ifr, key, newCookies, newValue, params, params_conf, posID;
      posID = msgObj && msgObj.pos;
      params = posID && rendered_ifrs[posID];
      params_conf = params && params.conf;
      id = params_conf && params_conf.dest;
      ifr = id && _elt(id);
      key = void 0;
      newValue = void 0;
      cookies = void 0;
      newCookies = void 0;
      command = "write-cookie";
      canRead = params_conf.supports && params_conf.supports[command] && params_conf.supports[command] !== "0";
      if (!canRead) {
        return;
      }
      if (!posID || !params || !ifr) {
        return;
      }
      key = msgObj.cookie;
      if (!key) {
        return;
      }
      newValue = escape(msgObj.value);
      exdate = new Date();
      exdate.setDate(exdate.getDate() + 1);
      c_value = newValue + "; expires=" + exdate.toUTCString();
      document.cookie = key + "=" + c_value;
      _fire_pub_callback(POS_MSG, command, posID, 0, 0);
      msgObj.cmd = command;
      msgObj.geom = _es(_build_geom(posID, ifr, true));
      msgObj.info = newValue;
      msgObj.value = "";
      _send_response(params, msgObj);
      ifr = params = msgObj = null;
    };

    /*
    Remove / destroy one or more SafeFrames from the publisher page
    
    @name $sf.host.nuke
    @static
    @function
    @public
    @param {String} pos_id* One or more position ids to remove from the page. If no arguments are specifed, all positions currently rendered are removed.
     */
    nuke = function() {
      var args, el, el_id, empty, idx, par, pos, pos_id, sb_rel;
      idx = 0;
      empty = true;
      args = arguments;
      pos_id = void 0;
      pos = void 0;
      el_id = void 0;
      el = void 0;
      sb_rel = void 0;
      par = void 0;
      if (!args[LEN] || args[idx] === "*") {
        args = [];
        for (pos_id in rendered_ifrs) {
          args.push(pos_id);
        }
      }
      while (pos_id = args[idx++]) {
        pos = rendered_ifrs[pos_id];
        if (pos) {
          if (pos_id in pending_ifrs) {
            clearTimeout(pending_ifrs[pos_id]);
            delete pending_ifrs[pos_id];
          }
          if (pos_id in complete_ifrs) {
            delete complete_ifrs[pos_id];
          }
          el_id = pos.dest;
          el = el_id && _elt(el_id);
          par = el && _par(el);
          if (dom.attr(par, "id").indexOf(POS_REL_BOX_ID_PREFIX) !== -1) {
            sb_rel = par;
            par = _par(sb_rel);
          }
          dom.purge(el);
          if (sb_rel) {
            dom.purge(sb_rel);
          }
          rendered_ifrs[pos_id] = null;
          delete rendered_ifrs[pos_id];
          el = dom.make("div");
          dom.attr(el, "id", el_id);
          dom.append(par, el);
        }
      }
      pos_id = "";
      for (pos_id in rendered_ifrs) {
        empty = false;
        break;
      }
      if (empty) {
        current_status = "";
        _handle_unload();
      }
    };

    /*
    Render one or more $sf.host.Position objects into the page
    
    @name $sf.host.render
    @public
    @static
    @function
    @param {$sf.host.Position} pos* An instance of an $sf.host.Position object to render. Note that said object must have a corresponding $sf.host.PosConfig, as well as $sf.host.Config must have been set
     */
    render = function() {
      var args, css_txt, dest_el, dest_id, dest_rel_id, e, finalCSSEnd, finalCSSPos, firstCSSPos, h, idx, name_params, new_dest_el, par_el, pend, pos, pos_conf, pos_id, rel_el, st, w;
      idx = 0;
      args = arguments;
      firstCSSPos = "relative";
      finalCSSPos = "absolute";
      finalCSSEnd = "top:0px;left:0px;visibility:hidden;display:none;";
      pos = void 0;
      pos_id = void 0;
      pos_conf = void 0;
      dest_el = void 0;
      new_dest_el = void 0;
      rel_el = void 0;
      par_el = void 0;
      name_params = void 0;
      dest_id = void 0;
      dest_rel_id = void 0;
      css_txt = void 0;
      w = void 0;
      h = void 0;
      st = void 0;
      e = void 0;
      pend = void 0;
      if (!config) {
        return false;
      }
      if (!dom.ready()) {
        dom.wait(function() {
          render.apply(null, args);
          args = null;
        });
        return null;
      }
      if ((args[0] instanceof Array) && args[LEN] === 1) {
        args = args[0];
      }
      while (pos = args[idx++]) {
        pos_id = pos.id;
        pos_conf = (pos_id ? config.positions[pos_id] : null);
        if (pos_conf) {
          dest_id = pos_conf.dest;
          dest_el = dest_id && _elt(dest_id);
          if (dest_el) {
            w = pos_conf.w;
            h = pos_conf.h;
            if (!w) {
              try {
                w = dest_el.offsetWidth;
              } catch (_error) {
                e = _error;
                w = 0;
              }
              if (w) {
                pos_conf.w = w;
              }
            }
            if (!h) {
              try {
                h = dest_el.offsetHeight;
              } catch (_error) {
                e = _error;
                h = 0;
              }
              if (h) {
                pos_conf.h = h;
              }
            }
            if (w && h) {
              name_params = new ParamHash();
              dest_rel_id = POS_REL_BOX_ID_PREFIX + "_" + pos_id;
              rel_el = _elt(dest_rel_id);
              par_el = _par(dest_el);
              if (rel_el && par_el === rel_el) {
                par_el = _par(rel_el);
              }
              _shim_frame(dest_id);

              /*
              @ignore
               */
              pend = pending_ifrs[pos_id];
              if (pend) {
                clearTimeout(pend);
              }
              pend = complete_ifrs[pos_id];
              if (pend) {
                delete complete_ifrs[pos_id];
              }
              pending_ifrs[pos_id] = setTimeout(function() {
                _handle_render_timeout(pos_id);
              }, config.to);
              current_status = "rendering";
              _fire_pub_callback("onStartPosRender", pos_id, pos_conf, pos);
              css_txt = ["position:", "", ";z-index:0;", WIDTH, ":", w, PX, ";", HEIGHT, ":", h, PX, ";", "visibility:inherit;"];
              if (!rel_el) {
                css_txt[1] = firstCSSPos;
                rel_el = dom.make("div");
                rel_el.id = dest_rel_id;
                rel_el.className = "iab_sf";
                new_dest_el = dest_el.cloneNode(false);
                dom.css(new_dest_el, css_txt);
                rel_el.appendChild(new_dest_el);
                dom.css(rel_el, css_txt);
                par_el.replaceChild(rel_el, dest_el);
                dest_el = _elt(dest_id);
              } else {
                st = rel_el[ST];
                st.width = w + PX;
                st.height = h + PX;
                st = dest_el && dest_el[ST];
                st.width = w + PX;
                st.height = h + PX;
              }
              name_params.id = pos_id;
              name_params.dest = dest_id;
              name_params.conf = ParamHash(pos_conf);
              name_params.meta = pos.meta.toString();
              name_params.html = _es(pos.html);
              name_params.geom = _es(_build_geom(pos_id, dest_el));
              name_params.src = config.renderFile;
              name_params.has_focus = lang.cstr(document.hasFocus());
              css_txt[1] = finalCSSPos;
              css_txt[13] = finalCSSEnd;
              if (!win_events_attached) {
                dom.attach(win, SCROLL, _handle_win_geom_scroll);
                dom.attach(win, "resize", _handle_win_geom_resize);
                dom.attach(win, "unload", _handle_unload);
                dom.attach(win, "focus", _handle_win_focus);
                dom.attach(win, "blur", _handle_win_blur);
                win_events_attached = true;
              }
              iframes.replace({
                id: dest_id,
                name: name_params,
                src: config.renderFile,
                _pos_id: pos_id
              }, css_txt, rel_el, _handle_frame_load, _handle_msg_evt);
              rendered_ifrs[pos_id] = name_params;
            }
          }
        }
      }
    };

    /*
    Gets a copy of the Position configuration, content, and meta data for a given SafeFrame
    
    @name $sf.host.get
    @public
    @function
    @static
    @return {Object}
     */
    get = function(positionId) {
      var obj;
      obj = rendered_ifrs[positionId];
      if (!obj) {
        return null;
      }
      return _mix({}, obj);
    };

    /*
    Returns a string as to whether or not the library is busy, empty string is returned on idle
    
    @name $sf.host.status
    @public
    @function
    @static
    @return {String}
     */
    status = function() {
      return current_status;
    };
    if (lang) {
      if (win === top) {
        _rect = (ieVer ? _getRectIE : _getRectNonIE);
        _mix(dom, {
          rect: _rect,
          currentStyle: currentStyle,
          contains: contains,
          docRect: docRect,
          winRect: winRect,
          bounds: bounds,
          overlaps: overlaps
        });

        /*
        @ignore
         */
        (function() {
          var e;
          e = void 0;
          dom.msghost = {
            prep: prep_iframe_msging,
            attach: attach_iframe_msging,
            detach: detach_iframe_msging,
            usingHTML5: usingHTML5,
            send: send_msg_to_child_iframe
          };
          dom[ATTACH](win, MSG, _check_html5_init);
          initID = "xdm-html5-init-" + _guid();
          locHost = (locHost.indexOf("file") === 0 ? locHost = "file" : locHost);
          try {
            win[PMSG](initID, (locHost === "file" ? "*" : locHost));
          } catch (_error) {
            e = _error;
            dom[DETACH](win, MSG, _check_html5_init);
          }
        })();
        _mix(sf.host, {
          Config: Config,
          PosConfig: PosConfig,
          PosMeta: PosMeta,
          Position: Position,
          nuke: nuke,
          get: get,
          render: render,
          status: status
        });
      }
    }
    return sf;
  })(window, sf);

}).call(this);

},{"./boot":2}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var dom, env, lang, logger;

  lang = require('./lang');

  env = require('./env');

  dom = require('./dom');

  logger = require('./logger');

  module.exports = (function(lang, env, dom, logger) {
    return {
      ver: "1-1-0",
      specVersion: "1.1",
      lib: {
        lang: lang,
        dom: dom,
        logger: logger
      },
      env: env,
      host: {},
      ext: {},
      info: {
        errs: [],
        list: []
      }
    };
  })(lang, env, dom, logger);

}).call(this);

},{"./dom":5,"./env":6,"./lang":7,"./logger":8}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var env, lang;

  lang = require('./lang');

  env = require('./env');

  module.exports = (function(window, lang, env) {
    var BLANK_URL, EVT_CNCL_METHODS, GC, IE_GC_INTERVAL, IFRAME, append, attach, attr, clone_iframe, css, detach, doc, dom, dom_is_ready, dom_last_known_child_node, dom_last_known_tag_count, dom_ready_chk_max_tries, dom_ready_chk_timer_id, dom_ready_chk_tries, dom_ready_chk_try_interval, elt, evtCncl, evtTgt, evt_tgt_prop_a, evt_tgt_prop_b, gc, gc_timer_id, ie_attach, ie_detach, iframe_cbs_attached, iframe_msg_host_lib, iframe_next_id, iframe_view, isIE, make_element, make_iframe, par, purge, ready, replace_iframe, tagName, tags, theDocument, useOldStyleAttrMethods, use_attach, use_detach, use_ie_old_attach, view, w3c_attach, w3c_detach, wait, win, _bind_iframe_onload, _byID, _call_xmsg_host, _callable, _clear_ready_timer_check, _clone_iframe, _cstr, _env, _handle_dom_load_evt, _lang, _ready_state_check, _unbind_iframe_onload;
    dom = {};
    _lang = lang;
    _env = env;
    win = window;
    IFRAME = "iframe";
    GC = "CollectGarbage";
    ie_attach = "attachEvent";
    w3c_attach = "addEventListener";
    ie_detach = "detachEvent";
    w3c_detach = "removeEventListener";
    use_attach = "";
    use_detach = "";
    use_ie_old_attach = false;
    IE_GC_INTERVAL = 3000;
    EVT_CNCL_METHODS = {
      "preventDefault": 0,
      "stopImmediatePropagation": 0,
      "stopPropagation": 0,
      "preventBubble": 0
    };
    isIE = env.isIE;
    useOldStyleAttrMethods = false;
    gc_timer_id = 0;
    dom_is_ready = null;
    dom_last_known_tag_count = 0;
    dom_last_known_child_node = null;
    dom_ready_chk_max_tries = 300;
    dom_ready_chk_try_interval = 50;
    dom_ready_chk_tries = 0;
    dom_ready_chk_timer_id = 0;
    iframe_next_id = 0;
    iframe_cbs_attached = {};
    evt_tgt_prop_a = "";
    evt_tgt_prop_b = "";
    iframe_msg_host_lib = null;
    theDocument = win.document;
    BLANK_URL = "about:blank";
    _cstr = lang.cstr;
    _callable = lang.callable;

    /*
    Clear out the timer function used as a fallback when ready state of the DOM
    cannot be directly detected
    
    @name $sf.lib.dom-_clear_ready_timer_check
    @private
    @static
    @function
     */
    _clear_ready_timer_check = function() {
      if (dom_ready_chk_timer_id) {
        clearTimeout(dom_ready_chk_timer_id);
        dom_ready_chk_timer_id = 0;
      }
    };
    _handle_dom_load_evt = function(evt) {
      detach(win, "load", _handle_dom_load_evt);
      detach(win, "DOMContentLoaded", _handle_dom_load_evt);
      dom_is_ready = true;
    };

    /*
    Checks to see if the DOM is ready to be manipulated, without the need for event hooking.
    Often times you'll see folks use the onload event or DOMContentLoaded event.  However
    the problem with those, is that your JavaScript code may have been loaded asynchronously,
    after either one of those events have fired, and in which case you still don't know if the DOM is really
    ready.  Most modern browsers (including IE), implement a document.readyState property that we can
    check, but not all.  In the case where this property is not implemented, we do a series of node
    checks and tag counts via timers.  Of course this means that on the very 1st call, we will always
    appear to be not ready eventhough the DOM itself may be in a ready state, but our timeout interval
    is small enough that this is OK.
    
    @name $sf.lib.dom-_ready_state_check
    @private
    @static
    @function
     */
    _ready_state_check = function() {
      var b, e, kids, lst, tag_cnt;
      _clear_ready_timer_check();
      if (dom_ready_chk_tries >= dom_ready_chk_max_tries) {
        dom_last_known_child_node = null;
        dom_is_ready = true;
      }
      if (dom_is_ready === null) {
        try {
          b = theDocument && theDocument.body;
          kids = b && tags("*", b);
          tag_cnt = kids && kids[LEN];
          lst = b && b.lastChild;
        } catch (_error) {
          e = _error;
          dom_last_known_tag_count = 0;
          dom_last_known_child_node = null;
        }
        if (dom_last_known_tag_count && tag_cnt === dom_last_known_tag_count && lst === dom_last_known_child_node) {
          dom_last_known_child_node = null;
          dom_is_ready = true;
        } else {
          dom_last_known_tag_count = tag_cnt;
          dom_last_known_child_node = lst;
          dom_ready_chk_tries += 1;
          dom_ready_chk_timer_id = setTimeout(_ready_state_check, dom_ready_chk_try_interval);
        }
      } else {
        dom_last_known_child_node = null;
      }
    };

    /*
    Detach onload handlers on iframes that we have created
    
    @name $sf.lib.dom.iframes-_unbind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to unbind from
     */
    _unbind_iframe_onload = function(el) {
      var id, oldCB;
      id = attr(el, "id");
      oldCB = void 0;
      oldCB = id && iframe_cbs_attached[id];
      if (oldCB) {
        detach(el, "load", oldCB);
        iframe_cbs_attached[id] = null;
        delete iframe_cbs_attached[id];
      }
    };

    /*
    A default onload event handler for IFrames. We don't
    want to attach to onload events for IFrames via attributes
    b/c we don't want others to see what handlers are there.
    In turn we also make sure the "this" reference for the outside
    handle gets set properly, and it allows us to make sure
    that unbinding of the event handler also gets handled always
    so as not to create memory leak issues.
    
    @name $sf.lib.dom.iframes-_bind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to bind too
    @param {Function} cb The onload handler from the outside
     */
    _bind_iframe_onload = function(el, cb) {
      var id, newCB;
      newCB = void 0;
      id = void 0;
      if (_callable(cb)) {

        /*
        @ignore
         */
        newCB = function(evt) {
          var e, tgt;
          tgt = evtTgt(evt);
          e = void 0;
          _unbind_iframe_onload(tgt);
          if (tgt && cb) {
            try {
              cb.call(tgt, evt);
            } catch (_error) {}
          }
          tgt = el = cb = newCB = id = null;
        };
        id = attr(el, "id");
        _unbind_iframe_onload(el);
        if (id) {
          iframe_cbs_attached[id] = newCB;
        }
        attach(el, "load", newCB);
      }
      newCB = null;
    };

    /*
    Return the element reference passed in, and if its a string value passed
    in use that to lookup the element by id attribute.
    
    @name $sf.lib.dom-_byID
    @private
    @static
    @function
    @param {HTMLElement|String} el  the element id / element reference
    @return {HTMLElement|el}
     */
    _byID = function(el) {
      if (el && typeof el === "string") {
        return elt(el) || el;
      } else {
        return el;
      }
    };

    /*
    A proxy wrapper for calling into the cross-domain messaging host library
    
    @name $sf.lib.dom.iframes-_call_xmsg_host
    @private
    @static
    @function
    @param {String} methName The method name in the msg host library to call
    @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
    @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
    @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
    @return {*} whatever comes back from the method
     */
    _call_xmsg_host = function(methName, arg1, arg2, arg3) {
      var e;
      e = void 0;
      try {
        if (!iframe_msg_host_lib) {
          iframe_msg_host_lib = dom.msghost;
        }
      } catch (_error) {
        e = _error;
        iframe_msg_host_lib = null;
      }
      if (win !== top) {
        return;
      }
      return methName && iframe_msg_host_lib && iframe_msg_host_lib[methName] && iframe_msg_host_lib[methName](arg1, arg2, arg3);
    };

    /*
    Retrieve a document for a given HTML Element
    
    @memberOf $sf.lib.dom
    @exports doc as $sf.lib.dom.doc
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element for which you wish to find it's parent document
    @return {Document|null} null if nothing found
     */
    doc = function(el) {
      var e, localD;
      localD = null;
      try {
        if (el) {
          if (el.nodeType === 9) {
            localD = el;
          } else {
            localD = el.document || el.ownerDocument || null;
          }
        }
      } catch (_error) {
        e = _error;
        localD = null;
      }
      return localD;
    };

    /*
    Retrieve the host window object for a given HTML Element/document. Note that this is NOT the same as $sf.lib.dom.iframes.view, which
    returns the window reference INSIDE the IFRAME element.
    
    @memberOf $sf.lib.dom
    @exports view as $sf.lib.dom.view
    @public
    @static
    @function
    @param {HTMLElement|HTMLDocument} el the HTML element/document for which you wish to find it's parent window
    @return {Document|null} null if nothing found
     */
    view = function(el) {
      var e, localD, prop1, prop2, w;
      w = null;
      localD = void 0;
      prop1 = "parentWindow";
      prop2 = "defaultView";
      try {
        if (el) {
          w = el[prop1] || el[prop2] || null;
          if (!w) {
            localD = doc(el);
            w = (localD && (localD[prop1] || localD[prop2])) || null;
          }
        }
      } catch (_error) {
        e = _error;
        w = null;
      }
      return w;
    };

    /*
    Retrieve an element by its ID. . basically a short hand wrapper around document.getElementById.
    
    @memberOf $sf.lib.dom
    @exports elt as $sf.lib.dom.elt
    @public
    @static
    @function
    @param {String} id (Required) the id of the HTML element to find
    @param {HTMLElement|HTMLWindow|HTMLDocument} [par] The parent element,document,window to look for the given element
    @return {HTMLElement|null} null if nothing found
     */
    elt = function(id) {
      var args, dc, len;
      args = arguments;
      len = args.length;
      dc = void 0;
      if (len > 1) {
        dc = doc(args[1]);
      } else {
        dc = theDocument;
      }
      return (dc && dc.getElementById(id)) || null;
    };

    /*
    A wrapper around retrieving the tagName of an HTML element (normalizes values to lower case strings).
    
    @memberOf $sf.lib.dom
    @exports tagName as $sf.lib.dom.tagName
    @static
    @public
    @function
    @param {HTMLElement} el The HTML element for which to get the tag name.
    @return {String} The tag name in all lower case of an HTML element, if it cannot be successfully retrieved, alwasys returns an empty string (which will evaluate to false).
     */
    tagName = function(el) {
      return (el && el.nodeType === 1 && el.tagName.toLowerCase()) || "";
    };

    /*
    A wrapper around retrieving a list of tags by name.
    
    @memberOf $sf.lib.dom
    @exports tags as $sf.lib.dom.tags
    @static
    @public
    @function
    @param {String} name The name of the tags that you wish to look for, note that you can pass in "*" to find all.
    @param {HTMLElement|Document} [parNode] the parent node that you wish to look in
    @return {HTMLElementCollection} List of tags found. Note that is NOT a real JavaScript Array
     */
    tags = function(name, parNode) {
      var e, ret;
      ret = [];
      e = void 0;
      try {
        if (parNode && parNode.getElementsByTagName) {
          ret = parNode.getElementsByTagName(name) || ret;
        } else {
          ret = theDocument.getElementsByTagName(name) || ret;
        }
      } catch (_error) {
        e = _error;
        ret = [];
      }
      return ret;
    };

    /*
    Retrive the parent element of an HTML element
    
    @memberOf $sf.lib.dom
    @exports par as $sf.lib.dom.par
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to check
    return {HTMLElement} the new reference to the parent element or null
     */
    par = function(el) {
      return el && (el.parentNode || el.parentElement);
    };

    /*
    Retrieve/Set/Delete an element's attribute. Note that this handle's
    slight differences in the way HTML attributes are handled across browsers
    as well as being shorthand
    
    @memberOf $sf.lib.dom
    @exports attr as $sf.lib.dom.attr
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} attrName the attribute to set/get
    @param {String} [attrVal], if specified will set the value of the attribute for this element.  Passing null will remove the attribute completely
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    attr = function(el, attrName, attrVal) {
      var e;
      e = void 0;
      try {
        if (arguments.length > 2) {
          if (attrVal === null) {
            if (useOldStyleAttrMethods) {
              el.removeAttribute(attrName, 0);
            } else {
              el.removeAttribute(attrName);
            }
          } else {
            attrVal = _cstr(attrVal);
            if (attrName.toLowerCase() === "class") {
              el.className = attrVal;
            } else {
              if (useOldStyleAttrMethods) {
                el.setAttribute(attrName, attrVal, 0);
              } else {
                el.setAttribute(attrName, attrVal);
              }
            }
          }
        } else {
          if (useOldStyleAttrMethods) {
            attrVal = _cstr(el.getAttribute(attrName, 0));
          } else {
            attrVal = _cstr(el.getAttribute(attrName));
          }
        }
      } catch (_error) {
        e = _error;
        attrVal = "";
      }
      return attrVal;
    };

    /*
    Set/Get the CSS text of an HTML element
    
    @memberOf $sf.lib.dom
    @exports css as $sf.lib.dom.css
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} [val] the CSS string to set if specified (e.g. "background-color:transparent;position:absolute;top:0px;left:0px").
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    css = function(el, val) {
      var e, st;
      st = void 0;
      try {
        st = el.style;
        if (arguments.length > 1) {
          st.cssText = _cstr(val);
        } else {
          val = st.cssText;
        }
      } catch (_error) {
        e = _error;
        val = "";
      }
      return val;
    };

    /*
    Make a new element
    
    @name $sf.lib.dom.make
    @exports make_element as $sf.lib.dom.make
    @static
    @public
    @function
    @param {String} tagName
    @param {Document|HTMLElement|Window} [parent] element, document, or window to make the tag in, optional.
    @return {HTMLElement}
     */
    make_element = function(tagName, par) {
      return ((arguments.length > 1 && doc(par)) || theDocument).createElement(tagName);
    };

    /*
    Append and HTMLElement to another HTMLElement
    
    @memberOf $sf.lib.dom
    @exports append as $sf.lib.dom.append
    @public
    @static
    @function
    @param {HTMLElement} parNode the HTML element to manipulate
    @param {HTMLElement} child (Required) the new HTML element to add to the parent
    return {HTMLElement|Boolean} the new reference to the child element that was appended, or false if failure
     */
    append = function(parNode, child) {
      var e, success;
      success = false;
      e = void 0;
      try {
        if (parNode) {
          success = parNode.appendChild(child);
        }
      } catch (_error) {
        e = _error;
        success = false;
      }
      return success;
    };

    /*
    A wrapper method for removing elements from a document rather than calling parentNode.removeChild raw.
    Has special processing to ensure that contents of IFRAME tags gets released from memory as well
    
    @memberOf $sf.lib.dom
    @exports purge as $sf.lib.dom.purge
    @static
    @public
    @function
    @param {HTMLElement} node The HTML element to be removed from the dom
    @return {Boolean} Whether or not the element was successfully removed
     */
    purge = function(node) {
      var e, isIFrame, parNode, success;
      success = false;
      parNode = void 0;
      isIFrame = tagName(node) === IFRAME;
      e = void 0;
      if (isIFrame) {
        _call_xmsg_host("detach", node);
        _unbind_iframe_onload(node);
        if (!isIE) {
          attr(node, "src", BLANK_URL);
        }
      }
      try {
        parNode = par(node);
        if (parNode) {
          parNode.removeChild(node);
          success = true;
          if (isIE && isIFrame) {
            gc();
          }
        }
      } catch (_error) {}
      node = parNode = null;
      return success;
    };

    /*
    Attach an event handler to an HTMLElement.  Note normalize event names to lower case / w3c standards.
    See example.
    
    @memberOf $sf.lib.dom
    @exports attach as $sf.lib.dom.attach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} name the name of the event to listen too
    @param {Function} cb the function used to handle the particular event
    
    @example
    var el = $sf.lib.dom.elt("my_element");
    function handle_click(evt)
    {
    alert('i was clicked');
    }
    
    $sf.lib.dom.attach(el,"click",handle_click);
     */
    attach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj[use_attach]("on" + name, cb);
        } else {
          obj[use_attach](name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Detach an event handler to an HTMLElement
    
    @memberOf $sf.lib.dom
    @exports detach as $sf.lib.dom.detach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} namethe name of the event to listen too
    @param {Function} cb the function used to handle the particular event
     */
    detach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj.detachEvent("on" + name, cb);
        } else {
          obj.removeEventListener(name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Returns whether or not the DOM is ready to be manipulated
    
    @memberOf $sf.lib.dom
    @exports ready as $sf.lib.dom.ready
    @public
    @static
    @function
    @return {Boolean}
     */
    ready = function() {
      var rs;
      rs = void 0;
      _clear_ready_timer_check();
      if (dom_is_ready) {
        dom_last_known_child_node = null;
        return true;
      }
      rs = theDocument.readyState;
      if (rs) {
        dom_last_known_child_node = null;
        if (rs === "loaded" || rs === "complete") {
          dom_is_ready = true;
        } else {
          dom_is_ready = false;
        }
      }
      dom_last_known_child_node = null;
      dom_ready_chk_tries = dom_last_known_tag_count = 0;
      _ready_state_check();
      return !!dom_is_ready;
    };

    /*
    Fire off a particular function when it is detected that the DOM is ready
    Useful when you don't know for sure if the DOM of the browser is ready or not, so this will detect and fire
    your function for you.
    
    @memberOf $sf.lib.dom
    @exports wait as $sf.lib.dom.wait
    @public
    @static
    @function
    @param {Function} cb A function reference to be called when the DOM is ready
     */
    wait = function(cb) {
      var e, rdy;
      rdy = ready();
      e = void 0;
      if (rdy) {
        try {
          if (lang.callable(cb)) {
            cb();
          }
        } catch (_error) {
          e = _error;
          e = null;
        }
        return;
      }
      setTimeout((function() {
        wait(cb);
        cb = null;
      }), dom_ready_chk_try_interval + 1);
    };

    /*
    Cancel the the default action of a particular DOM event
    
    @memberOf $sf.lib.dom
    @exports evtCncl as $sf.lib.dom.evtCncl
    @public
    @static
    @function
    @param {HTMLEvent} evt  The raw HTML event
     */
    evtCncl = function(evt) {
      var e, prop;
      prop = "";
      e = void 0;
      evt = evt || win.event;
      if (evt) {
        try {
          evt.returnValue = false;
        } catch (_error) {}
        try {
          evt.cancelBubble = true;
        } catch (_error) {}
        try {
          evt.stopped = true;
        } catch (_error) {}
        for (prop in EVT_CNCL_METHODS) {
          if (EVT_CNCL_METHODS[prop]) {
            try {
              evt[prop]();
            } catch (_error) {}
          }
        }
      }
      return false;
    };

    /*
    Return the target/srcElement of an event from an HTML element
    
    @memberOf $sf.lib.dom
    @exports evtTgt as $sf.lib.dom.evtTgt
    @public
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event
     */
    evtTgt = function(evt) {
      var e, tgt;
      tgt = null;
      try {
        evt = evt || win.event;
        tgt = (evt ? evt[evt_tgt_prop_a] || evt[evt_tgt_prop_b] : null);
      } catch (_error) {
        e = _error;
        tgt = null;
      }
      return tgt;
    };

    /*
    @namespace $sf.lib.dom.iframes Defines helper functions for dealing specifically with IFRAME tags, which is key to SafeFrames tech in a browser.
    @name $sf.lib.dom.iframes
    @requires $sf.lib.lang
     */

    /*
    Clones an iframe. . .
    This code creates / clones iframe tags in a very specific way to ensure both optimal performance and stability.
    We use string buffers to build markup internally, which is typically faster than using all DOM APIs.  Also
    we allow the usage of the "name" attribute as a data pipeline, which in turn allows for synchronous downward
    x-domain messaging.
    
    @name $sf.lib.dom.iframes.clone
    @static
    @public
    @function
    @param {HTMLElement/String} el  An iframe element or id of an iframe element to clone
    @param {Object} [attrs]  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An optional callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An optional call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    clone_iframe = function(el, attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(el, attrs, cssText, cb, xmsgCB);
    };

    /*
    @ignore
     */
    _clone_iframe = function(el, attrs, cssText, cb, xmsgCB, iframe_skip_clone) {
      var attrStr, bufferHTML, cl, html, newCl, prop, temp, xmsgPipe;
      bufferHTML = ["<", IFRAME, " "];
      xmsgPipe = "";
      prop = void 0;
      temp = void 0;
      cl = void 0;
      newCl = void 0;
      html = void 0;
      attrStr = void 0;
      if (!iframe_skip_clone) {
        el = _byID(el);
        if (tagName(el) !== IFRAME) {
          return null;
        }
        cl = el.cloneNode(false);
      } else {
        cl = el;
      }
      attrs = attrs || {};
      if ("src" in attrs) {
        attr(cl, "src", null);
      } else {
        attrs.src = attr(el, "src") || BLANK_URL;
      }
      if ("name" in attrs) {
        attr(cl, "name", null);
      } else {
        attrs.name = attr(el, "name");
      }
      if (!attrs.src) {
        attrs.src = BLANK_URL;
      }
      xmsgPipe = xmsgCB && _call_xmsg_host("prep", attrs);
      if (!iframe_skip_clone) {
        attr(cl, "width", null);
        attr(cl, "height", null);
      }
      if (cssText) {
        temp = css(cl);
        if (temp && temp.charAt(temp.length - 1) !== ";") {
          temp += ";";
        }
        css(cl, [temp, _cstr(cssText)]);
      }
      temp = make_element("div");
      append(temp, cl);
      html = temp.innerHTML;
      attrStr = html.replace(/<iframe(.*?)>(.*?)<\/iframe>/g, "$1");
      bufferHTML.push("name=\"", attrs.name, "\" ", attrStr, "></", IFRAME, ">");
      delete attrs.name;
      temp.innerHTML = _cstr(bufferHTML);
      newCl = temp.firstChild;
      for (prop in attrs) {
        attr(newCl, prop, attrs[prop]);
      }
      if (!attr(newCl, "id")) {
        attr(newCl, "id", "sf_" + IFRAME + "_" + iframe_next_id);
        iframe_next_id++;
      }
      attr(newCl, "FRAMEBORDER", "no");
      attr(newCl, "SCROLLING", "no");
      attr(newCl, "ALLOWTRANSPARENCY", true);
      attr(newCl, "HIDEFOCUS", true);
      attr(newCl, "TABINDEX", -1);
      attr(newCl, "MARGINWIDTH", 0);
      attr(newCl, "MARGINHEIGHT", 0);
      _bind_iframe_onload(newCl, cb);
      if (xmsgPipe) {
        _call_xmsg_host("attach", newCl, xmsgPipe, xmsgCB);
      }
      xmsgPipe = xmsgCB = cl = cb = el = temp = null;
      return newCl;
    };

    /*
    Make a new iframe
    
    @name $sf.lib.dom.iframes.make
    @static
    @public
    @function
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    make_iframe = function(attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(make_element(IFRAME), attrs, cssText, cb, xmsgCB, true);
    };

    /*
    A method to insert or replace an HTML tag with an IFRAME tag, with a new URL and attributes.
    
    Used for 3 reasons:
    <ol>
    <li>It avoids click sounds on IE.</li>
    <li>It allows always resetting the window.name property of the iframes underlying HTMLWindow object, unforunately IE will not let you set this attribute on a clone.</li>
    <li>It ensures that event handlers in the underlying document for unloading are executed.</li>
    <li>Changing the src attribute directly will result in a browser history update, which we do not want.</li>
    </ol>
    
    We could just change location.href property or call location.replace, however that is not always  possible since
    the frame could be x-domain.
    
    @name $sf.lib.dom.iframes.replace
    @function
    @static
    @public
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {HTMLElement|String} [parRef]  An parent element or parent element id, to be used only if a new iframe is created, the iframe will be append to that parent, if not specified document body is used
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    
    @return {HTMLElement} a reference to the newly created iframe element if successfully inserted, otherwise null.
     */
    replace_iframe = function(attrs, cssText, parRef, cb, xmsgCB) {
      var cl, e, el, elID, frameEl, parNode, tgn;
      cl = void 0;
      el = void 0;
      frameEl = void 0;
      elID = void 0;
      tgn = void 0;
      parNode = void 0;
      e = void 0;
      attrs = attrs || {};
      elID = attrs.id;
      el = elID && _byID(elID);
      tgn = tagName(el);
      el = (tgn ? el : null);
      frameEl = (tgn === IFRAME ? el : null);
      if (frameEl) {
        _call_xmsg_host("detach", frameEl);
        _unbind_iframe_onload(frameEl);
        parNode = par(frameEl);
        cl = clone_iframe(frameEl, attrs, cssText, cb, xmsgCB);
        attr(cl, "onload", null);
        attr(cl, "onreadystatechange", null);
      } else {
        if (parRef) {
          parRef = _byID(parRef);
          if (tagName(parRef)) {
            parNode = parRef;
          }
        }
        if (!parNode && el) {
          parNode = par(el);
        }
        cssText = _cstr(cssText) || css(el) || "";
        cl = make_iframe(attrs, cssText, cb, xmsgCB);
      }
      try {
        if (!parNode) {
          append(theDocument.body, cl);
        } else {
          if (frameEl) {
            parNode.replaceChild(cl, frameEl);
          } else {
            if (el) {
              parNode.replaceChild(cl, el);
            } else {
              append(parNode, cl);
            }
          }
        }
      } catch (_error) {}
      cl = el = attrs = frameEl = parNode = cb = null;
      return elt(elID);
    };

    /*
    Retrieve the window reference inside of an IFRAME. Not to be confused with $sf.lib.dom.view which
    returns the parent window reference of an element.
    
    Note that even in cross-domain scenarios, you are supposed to able to get access to the window reference.
    In a cross-domain scenario, you would not be able to then acesss most properties / methods / objects of that
    window, but the reference itself is allowed.
    
    @name $sf.lib.dom.iframes.view
    @public
    @static
    @function
    @param {HTMLElement} el The iframe element to safely get back the window
    @return {HTMLWindow} the window reference inside the iframe.
     */
    iframe_view = function(el) {
      var e, elDoc, elWin, err, fe, frame, frame_list, idx, localWin;
      localWin = void 0;
      elWin = void 0;
      elDoc = void 0;
      frame_list = void 0;
      frame = void 0;
      fe = void 0;
      idx = 0;
      e = void 0;
      err = void 0;
      try {
        localWin = el.contentWindow || null;
        if (!win) {
          elDoc = doc(el);
          elWin = elDoc && view(elDoc);
          frame_list = (elWin && elWin.frames) || [];
          while (frame = frame_list[idx++]) {
            try {
              fe = frame.frameElement;
            } catch (_error) {
              err = _error;
              fe = null;
            }
            if (fe && fe === el) {
              localWin = frame;
              break;
            }
          }
        }
      } catch (_error) {
        e = _error;
        localWin = null;
      }
      return localWin;
    };

    /*
    @ignore
     */
    gc = _lang.noop;
    (function() {
      var ATTR_NAME, CREATE_EVENT, EVT_TYPE, err, obj, prop;
      obj = void 0;
      ATTR_NAME = "SCROLLING";
      CREATE_EVENT = "createEvent";
      EVT_TYPE = "UIEvent";
      prop = void 0;
      err = void 0;
      if (isIE) {
        evt_tgt_prop_a = "srcElement";
        evt_tgt_prop_b = "target";
        obj = make_element(IFRAME);
        attr(obj, ATTR_NAME, "no");
        useOldStyleAttrMethods = attr(obj, ATTR_NAME) !== "no";
        if (GC in win) {

          /*
          @ignore
           */
          gc = function() {
            if (gc_timer_id) {
              clearTimeout(gc_timer_id);
            }
            gc_timer_ig(setTimeout(function() {
              try {
                win[GC]();
              } catch (_error) {}
            }, IE_GC_INTERVAL));
          };
        } else {
          gc = _lang.noop;
        }
      } else {
        evt_tgt_prop_a = "target";
        evt_tgt_prop_b = "currentTarget";
      }
      if (win[w3c_attach] && !isIE) {
        use_attach = w3c_attach;
        use_detach = w3c_detach;
      } else if (isIE) {
        use_ie_old_attach = true;
        use_attach = ie_attach;
        use_detach = ie_detach;
      }
      obj = null;
      try {
        obj = theDocument[CREATE_EVENT](EVT_TYPE);
      } catch (_error) {
        err = _error;
        obj = null;
      }
      if (!obj) {
        try {
          obj = theDocument[CREATE_EVENT](EVT_TYPE + "s");
        } catch (_error) {
          err = _error;
          obj = null;
        }
      }
      if (obj) {
        for (prop in EVT_CNCL_METHODS) {
          if (obj[prop]) {
            EVT_CNCL_METHODS[prop] = 1;
          }
        }
      }
      obj = null;
      attach(win, "load", _handle_dom_load_evt);
      return attach(win, "DOMContentLoaded", _handle_dom_load_evt);
    })();
    return dom = {
      doc: doc,
      view: view,
      elt: elt,
      tagName: tagName,
      tags: tags,
      par: par,
      make: make_element,
      css: css,
      attr: attr,
      gc: gc,
      append: append,
      purge: purge,
      attach: attach,
      detach: detach,
      ready: ready,
      wait: wait,
      evtCncl: evtCncl,
      evtTgt: evtTgt,
      iframes: {
        make: make_iframe,
        clone: clone_iframe,
        replace: replace_iframe,
        view: iframe_view
      }
    };
  })(window, lang, env);

}).call(this);

},{"./env":6,"./lang":7}],6:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var lang,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  lang = require('./lang');

  module.exports = (function(window) {
    var cached_ua, isIE, isIE11, navigator, theDocument, ua, userAgent, win;
    win = window;
    navigator = window.navigator;
    theDocument = window.document;
    userAgent = (navigator != null ? navigator.userAgent : void 0) || "";
    isIE11 = !window.ActiveXObject && __indexOf.call(window, "ActiveXObject") >= 0;
    isIE = !isIE11 && (win && (__indexOf.call(win, "ActiveXObject") >= 0));
    cached_ua = null;
    ua = (function() {

      /*
      Convert a version string into a numeric value
      
      @name $sf.env.ua-_numberify
      @static
      @private
      @function
      @param {String} s The string representing a version number (e.g. 'major.minor.revision')
      @returns {Number}
       */
      var parse_ua, _matchIt, _numberify, _testIt;
      _numberify = function(s) {
        var c;
        c = 0;
        return parseFloat(s.replace(/\./g, function() {
          if (c++ === 1) {
            return "";
          } else {
            return ".";
          }
        }));
      };

      /*
      Wrapper method for returning values from a regular expression match safely.
      
      @name $sf.env.ua-_matchIt
      @static
      @private
      @function
      @param {String} str The string to match against
      @param {RegExp} regEx The regular expression to use for matching
      @param {Number} [idx] The index number of a match to pull from
      @returns {String}
       */
      _matchIt = function(str, regEx, idx) {
        var m;
        m = str && str.match(regEx);
        if (!(idx != null)) {
          return m;
        } else {
          return (m && m[idx]) || null;
        }
      };

      /*
      Wrapper method for testing a string against a regular expression
      
      @name $sf.env.ua-_testIt
      @static
      @private
      @function
      @param {RegExp} regEx The regular expression to test with
      @param {String} str The string to test against
      @param {Boolean}
       */
      _testIt = function(regEx, str) {
        return regEx.test(str);
      };

      /*
      Parse a user-agent string from the browser and gather pertinent browser, and OS information
      
      @name $sf.env.ua.parse
      @static
      @public
      @function
      @param {String} [subUA] An alternate user-agent string to parse. If no valid string is passed in, function will return an object based on the known user-agent
      @returns {Object} <b>parsed</b> Browser and OS information<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ie  The major version number of the Internet Explorer browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.opera The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.gecko The major version number of the Gecko (Firefox) browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webkit The major version number of the WebKit browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.safari The major version number of the Safari browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.chrome The major version number of the Chrome browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.air The major version number of the AIR SDK being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipod Whether or not an iPod device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipad Whether or not an iPad device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.iphone Whether or not an iPhone device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.android The major version number of the Android OS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webos The major version number of the WebOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.silk The major version number of the Silk browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.nodejs The major version number of the NodeJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.phantomjs The major version number of the PhantomJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {String} <b>parsed</b>.mobile A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ios The major version number of the iOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Boolean} <b>parsed</b>.accel Whether or not the browser / environment in question is hardware accelerated.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.cajaVersion The major version number of the CAJA environment or 0 if not.
       */
      parse_ua = function(subUA) {
        var date, e, match, ret;
        ret = {};
        date = new Date();
        if (!subUA && cached_ua) {
          return cached_ua;
        }
        ret.ie = ret.opera = ret.gecko = ret.webkit = ret.safari = ret.chrome = ret.air = ret.ipod = ret.ipad = ret.iphone = ret.android = ret.webos = ret.silk = ret.nodejs = ret.phantomjs = 0;
        ret.mobile = ret.ios = ret.os = null;
        ret.accel = false;
        ret.caja = navigator && navigator.cajaVersion;
        ret.cks = false;
        subUA = subUA || userAgent || "";
        if (subUA) {
          if (_testIt(/windows|win32/i, subUA)) {
            ret.os = "windows";
          } else if (_testIt(/macintosh|mac_powerpc/i, subUA)) {
            ret.os = "macintosh";
          } else if (_testIt(/android/i, subUA)) {
            ret.os = "android";
          } else if (_testIt(/symbos/i, subUA)) {
            ret.os = "symbos";
          } else if (_testIt(/linux/i, subUA)) {
            ret.os = "linux";
          } else {
            if (_testIt(/rhino/i, subUA)) {
              ret.os = "rhino";
            }
          }
          if (_testIt(/KHTML/, subUA)) {
            ret.webkit = 1;
          }
          if (_testIt(/IEMobile|XBLWP7/, subUA)) {
            ret.mobile = "windows";
          }
          if (_testIt(/Fennec/, subUA)) {
            ret.mobile = "gecko";
          }
          match = _matchIt(subUA, /AppleWebKit\/([^\s]*)/, 1);
          if (match) {
            ret.webkit = _numberify(match);
            ret.safari = ret.webkit;
            if (_testIt(/PhantomJS/, subUA)) {
              match = _matchIt(subUA, /PhantomJS\/([^\s]*)/, 1);
              if (match) {
                ret.phantomjs = _numberify(match);
              }
            }
            if (_testIt(RegExp(" Mobile\\/"), subUA) || _testIt(/iPad|iPod|iPhone/, subUA)) {
              ret.mobile = "Apple";
              match = _matchIt(subUA, /OS ([^\s]*)/, 1);
              match = match && _numberify(match.replace("_", "."));
              ret.ios = match;
              ret.ipad = ret.ipod = ret.iphone = 0;
              match = _matchIt(subUA, /iPad|iPod|iPhone/, 0);
              if (match) {
                ret[match.toLowerCase()] = ret.ios;
              }
            } else {
              match = _matchIt(subUA, /NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/, 0);
              if (match) {
                ret.mobile = match;
              }
              if (_testIt(/webOS/, subUA)) {
                ret.mobile = "WebOS";
                match = _matchIt(subUA, /webOS\/([^\s]*);/, 1);
                if (match) {
                  ret.webos = _numberify(match);
                }
              }
              if (_testIt(RegExp(" Android"), subUA)) {
                ret.mobile = "Android";
                match = _matchIt(subUA, /Android ([^\s]*);/, 1);
                if (match) {
                  ret.android = _numberify(match);
                }
              }
              if (_testIt(/Silk/, subUA)) {
                match = _matchIt(subUA, /Silk\/([^\s]*)\)/, 1);
                if (match) {
                  ret.silk = _numberify(match);
                }
                if (!ret.android) {
                  ret.android = 2.34;
                  ret.os = "Android";
                }
                if (_testIt(/Accelerated=true/, subUA)) {
                  ret.accel = true;
                }
              }
            }
            match = subUA.match(/(Chrome|CrMo)\/([^\s]*)/);
            if (match && match[1] && match[2]) {
              ret.chrome = _numberify(match[2]);
              ret.safari = 0;
              if (match[1] === "CrMo") {
                ret.mobile = "chrome";
              }
            } else {
              match = _matchIt(subUA, /AdobeAIR\/([^\s]*)/);
              if (match) {
                ret.air = match[0];
              }
            }
          }
          if (!ret.webkit) {
            match = _matchIt(subUA, /Opera[\s\/]([^\s]*)/, 1);
            if (match) {
              ret.opera = _numberify(match);
              match = _matchIt(subUA, /Opera Mini[^;]*/, 0);
              if (match) {
                ret.mobile = match;
              }
            } else {
              match = _matchIt(subUA, /MSIE\s([^;]*)/, 1);
              if (match) {
                ret.ie = _numberify(match);
              } else {
                match = _matchIt(subUA, /Gecko\/([^\s]*)/);
                if (match) {
                  ret.gecko = 1;
                  match = _matchIt(subUA, /rv:([^\s\)]*)/, 1);
                  if (match) {
                    ret.gecko = _numberify(match);
                  }
                }
              }
            }
          }
        }
        try {
          date.setTime(date.getTime() + 1000);
          theDocument.cookie = lang.cstr(["sf_ck_tst=test; expires=", date.toGMTString(), "; path=/"]);
          if (theDocument.cookie.indexOf("sf_ck_tst") !== -1) {
            ret.cks = true;
          }
        } catch (_error) {
          e = _error;
          ret.cks = false;
        }
        try {
          if (typeof process === "object") {
            if (process.versions && process.versions.node) {
              ret.os = process.platform;
              ret.nodejs = numberify(process.versions.node);
            }
          }
        } catch (_error) {
          e = _error;
          ret.nodejs = 0;
        }
        return ret;
      };

      /*
      The major version number of the Internet Explorer browser being used, or 0 if not.
      
      @name $sf.env.ua.ie
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @name $sf.env.ua.opera
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Gecko (Firefox) browser being used, or 0 if not.
      @name $sf.env.ua.gecko
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebKit browser being used, or 0 if not.
      @name $sf.env.ua.webkit
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Safari browser being used, or 0 if not.
      @name $sf.env.ua.safari
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Chrome browser being used, or 0 if not.
      @name $sf.env.ua.chrome
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the AIR SDK being used, or 0 if not.
      @name $sf.env.ua.air
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPod device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipod
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPad device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipad
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPhone device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.iphone
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Android OS being used, or 0 if not.
      @name $sf.env.ua.android
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebOS being used, or 0 if not.
      @name $sf.env.ua.webos
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Silk browser being used, or 0 if not.
      @name $sf.env.ua.silk
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the NodeJS environment being used, or 0 if not.
      @name $sf.env.ua.nodejs
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the PhantomJS environment being used, or 0 if not.
      @name $sf.env.ua.phantomjs
      @type {Number}
      @public
      @static
       */

      /*
      A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.
      
      @name $sf.env.ua.mobile
      @type {String}
      @public
      @static
       */

      /*
      The major version number of the iOS being used, or 0 if not.
      @name $sf.env.ua.ios
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not the browser / environment in question is hardware accelerated.
      @name $sf.env.ua.accel
      @type {Boolean}
      @public
      @static
       */

      /*
      The major version number of the CAJA environment or 0 if not
      @name $sf.env.ua.cajaVersion
      @type {Number}
      @public
      @static
       */
      cached_ua = parse_ua();
      cached_ua.parse = parse_ua;
      return cached_ua;
    })();
    return {
      ua: ua,
      isIE: isIE
    };
  })(window);

}).call(this);

}).call(this,require("/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./lang":7,"/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":9}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var ParamHash, backSlash, callable, cbool, cnum, cstr, def, entityMap, entityRegexes, guid, isArray, jssafe_html, lang, mix, next_id, noop, ns, proto, rand, scrip_str, time, toString, trim, win, _es, _keys, _ue;
    next_id = 0;
    win = window;
    backSlash = String.fromCharCode(92);
    scrip_str = 'scr"+"ipt';
    _es = win.escape;
    _ue = win.unescape;

    /*
    A function reference that does nothing.
    
    @memberOf $sf.lib.lang
    @exports noop as $sf.lib.lang.noop
    @static
    @function
    @public
    @return undefined
     */
    noop = function() {

      /*
      Forces type conversion of any JavaScript variable to a string value.
      Note that "falsy" values or values that cannot be converted will be returned
      as an empty string ("").
      
      @memberOf $sf.lib.lang
      @exports cstr as $sf.lib.lang.cstr
      @static
      @public
      @function
      @param {*} str  Any object that needs to be converted to a string value.
      @return {String}  The normalized string value.
       */
    };
    cstr = function(str) {
      var typ;
      typ = typeof str;
      if (typ === "string") {
        return str;
      }
      if (typ === "number" && !str) {
        return "0";
      }
      if (typ === "object" && str && str.join) {
        return str.join("");
      }
      if (typ === "boolean") {
        return str.toString();
      }
      if (str) {
        return String(str);
      } else {
        return "";
      }
    };

    /*
    Forces type conversion of any JavaScript variable to a boolean.
    "Falsy" values such as "", 0, null, and undefined all return false
    String values of  "0", "false", "no", "undefined", "null" also return false
    
    @memberOf $sf.lib.lang
    @exports cbool as $sf.lib.lang.cbool
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @return {Boolean} The normalized boolean value
     */
    cbool = function(val) {
      return !([void 0, "0", "false", "no", "undefined", "null", null].indexOf(val) >= 0 || false);
    };
    _keys = function(obj) {
      var k, _v;
      return (typeof Object.keys === "function" ? Object.keys(obj) : void 0) || ((function() {
        var _results;
        _results = [];
        for (k in obj) {
          _v = obj[k];
          _results.push(k);
        }
        return _results;
      })());
    };

    /*
    Forces type conversion of any JavaScript variable to a number.
    Values / objects that cannot be converted, will be returned as NaN, unless
    a default value is specified, in which case the default value is used.
    
    @memberOf $sf.lib.lang
    @exports cnum as $sf.lib.lang.cnum
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @param {*} [defVal] use this value if original value cannot be converted to a number, or if value is less than min value, or if value is less than max value.
    @param {Number} [minVal] specifies the lowest numerical value, if original value is less than this value, the defVal will be returned.
    @param {Number} [maxVal] specifies the greatest numerical value, if original value is greater than this value, the defVal will be returned.
    @return {Number|NaN|*} the converted value, otherwise NaN or default value
     */
    cnum = function(val, defVal, minVal, maxVal) {
      var e;
      if (typeof val !== "number") {
        try {
          if (!val) {
            val = Number.NaN;
          } else {
            val = parseFloat(val);
          }
        } catch (_error) {
          e = _error;
          val = Number.NaN;
        }
      }
      if (maxVal == null) {
        maxVal = Number.MAX_VALUE;
      }
      if (minVal == null) {
        minVal = -Number.MAX_VALUE;
      }
      if ((isNaN(val) || val < minVal || val > maxVal) && (defVal != null)) {
        return defVal;
      } else {
        return val;
      }
    };

    /*
    Checks that a function reference can be called safely.  Sometimes function references are part
    of objects that may have been garbage collected (such as a function reference from another window or dom element).
    This method checks the reference by making sure it has a constructor and toString properties.
    
    Note that this doesn't mean that the function itself when called (or its subsquent call stack), can't throw an error. . .
    simply that you are able to call it. . .
    
    this can problem be removed in lieu of func?() in cs
    
    @memberOf $sf.lib.lang
    @exports callable as $sf.lib.lang.callable
    @static
    @public
    @function
    @param {Function} A reference to a JavaScript function
    @return {Boolean} true if function can be called safely, otherwise false.
     */
    callable = function(f) {
      var e;
      try {
        f = (f && typeof f === "function" && f.toString() && (new f.constructor()) ? f : null);
      } catch (_error) {
        e = _error;
        f = null;
      }
      return !!f;
    };

    /*
    Generate a unique id string
    
    @memberOf $sf.lib.lang
    @exports guid as $sf.lib.lang.guid
    @static
    @public
    @function
    @param {String} [prefix] a substring to use a prefix
    @return {String} unique id string
     */
    guid = function(prefix) {
      return cstr([prefix || "", "_", time(), "_", rand(), "_", next_id++]);
    };

    /*
    Mixed the properties of one object into another object.
    Note that this function is recursive
    
    
    
    @memberOf $sf.lib.lang
    @exports mix as $sf.lib.lang.mix
    @static
    @public
    @function
    @param {Object}  r  The object that will receive properties
    @param {Object}  s  The object that will deliever properties
    @param {Boolean} [owned] Whether or not to skip over properties that are part of the object prototype
    @param {Boolean} [skipFuncs] Whether or not to skip over function references
    @param {Boolean} [no_ovr] Whether or not to overwrite properties that may have already been filled out
    @return {Object} The receiver object passed in with potentially new properties added
     */
    mix = function(r, s, owned, skipFuncs, no_ovr) {
      var item, p, typ;
      if (!s || !r) {
        return r;
      }
      for (p in s) {
        item = s[p];
        typ = typeof item;
        if (owned && !s.hasOwnProperty(p)) {
          continue;
        }
        if (no_ovr && (p in r)) {
          continue;
        }
        if (skipFuncs && typ === "function") {
          continue;
        }
        if (typ === "object" && item) {
          if (item.slice) {
            item = mix([], item);
          } else {
            item = mix({}, item);
          }
        }
        r[p] = item;
      }
      return r;
    };

    /*
    Return the current time in milliseconds, from the epoch
    
    @memberOf $sf.lib.lang
    @exports time as $sf.lib.lang.time
    @public
    @function
    @static
    @return {Number} current time
     */
    time = function() {
      return (new Date()).getTime();
    };

    /*
    Return a random integer anywhere from 0 to 99
    
    @memberOf $sf.lib.lang
    @exports rand as $sf.lib.lang.rand
    @public
    @static
    @function
    @return {Number} random number
     */
    rand = function() {
      return Math.round(Math.random() * 100);
    };

    /*
    Trim the begining and ending whitespace from a string.
    Note that this function will convert an argument to a string first
    for type safety purposes. If string cannot be converted, and empty string is returned
    
    @memberOf $sf.lib.lang
    @exports trim as $sf.lib.lang.trim
    @return {String} trimmed string
    @public
    @function
    @static
     */
    trim = function(str) {
      var ret;
      ret = cstr(str);
      return ret && ret.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    };

    /*
    Define a JavaScript Namespace within a given context
    
    @memberOf $sf.lib.lang
    @exports def as $sf.lib.lang.def
    @param {String} str_ns  The name of the namespace in dot notation as a string (e.g. "Foo.bar")
    @param {Object} [aug] defines the object at the end of the namespace.  If namespace is already specified, and this object is provided, the namespace will be augmented with properties from this object. If nothing is passed in, defaults to using an empty object.
    @param {Object} [root] the root object from which the namespace is defined.  If not passed in defaults to the global/window object
    @param {Boolean} [no_ovr] if true, properties already defined on root with the same name will be ignored
    @public
    @function
    @static
    @return {Object} The object at the end of the namespace
     */
    def = function(str_ns, aug, root, no_ovr) {
      var ar, idx, item, obj, per, ret;
      obj = (root && typeof root === "object" ? root : win);
      idx = 0;
      per = ".";
      ret = null;
      if (str_ns) {
        str_ns = cstr(str_ns);
        aug = (aug && typeof aug === "object" ? aug : null);
        if (str_ns.indexOf(per)) {
          ar = str_ns.split(per);
          while (item = ar[idx++]) {
            item = trim(item);
            if (idx === ar.length) {
              if (obj[item] && aug) {
                ret = obj[item] = mix(obj[item], aug, false, null, no_ovr);
              } else {
                if (no_ovr && (item in obj)) {
                  ret = obj[item];
                } else {
                  ret = obj[item] = obj[item] || aug || {};
                }
              }
            } else {
              if (no_ovr && (item in obj)) {
                ret = obj[item];
              } else {
                ret = obj[item] = obj[item] || {};
              }
            }
            obj = obj[item];
          }
        } else {
          if (obj[str_ns] && aug) {
            ret = obj[str_ns] = mix(obj[str_ns], aug, false, null, no_ovr);
          } else {
            ret = obj[str_ns] = obj[str_ns] || aug || {};
          }
        }
      }
      return ret;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.ns
    @param {String} str_ns  A string with . or [] notation of a JavaScript namesace (e.g. "foo.bar.show", or "foo['bar']['show']").
    @param {Object} [root] the root object to check within. .defaults to global / window
    @return {*} The endpoint reference of the namespace or false if not found
    @public
    @function
    @static
     */
    ns = function(str_ns, root) {
      var exists, exp, exp2, exp3, exp4, idx, matches, obj, prop, rootStr;
      exp = /(\[(.{1,})\])|(\.\w+)/g;
      exp2 = /\[(('|")?)((\s|.)*?)(('|")?)\]/g;
      exp3 = /(\[.*)|(\..*)/g;
      exp4 = /\./g;
      idx = 0;
      rootStr = "";
      exists = true;
      obj = root = root || win;
      if (str_ns) {
        str_ns = cstr(str_ns);
        if (str_ns) {
          str_ns = trim(str_ns);
          matches = str_ns.match(exp);
          if (matches) {
            rootStr = str_ns.replace(exp3, "");
            matches.unshift(rootStr);
            while (prop = matches[idx++]) {
              prop = prop.replace(exp2, "$3").replace(exp4, "");
              if (!obj[prop]) {
                exists = false;
                break;
              }
              obj = obj[prop];
            }
          } else {
            prop = str_ns;
            obj = obj[prop];
          }
        } else {
          exists = false;
        }
      } else {
        exists = false;
      }
      return (exists && obj) || false;
    };

    /*
    @function
    Tests to see if the object passed in is an array
     */
    isArray = function(obj) {
      if (obj == null) {
        return false;
      }
      if (typeof obj === "string") {
        return false;
      }
      if ((obj.length != null) && obj.constructor === Array) {
        return true;
      }
      return false;
    };

    /*
    Given a string of HTML escape quote marks and seperate script tags so that browsers don't get tripped up
    during processing.
    
    @memberOf $sf.lib.lang
    @exports jssafe_html as $sf.lib.lang.jssafe_html
    @param {String} str A string of HTML markup to be processed
    @return {String}
    @function
    @static
    @public
     */
    entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityRegexes = {
      escape: new RegExp('[' + _keys(entityMap.escape).join('') + ']', 'g')
    };
    jssafe_html = function(str) {
      if (str == null) {
        return '';
      }
      return ('' + string).replace(entityRegexes.escape, function(match) {
        return entityMap.escape[match];
      });
    };

    /*
    @class Intantiable class used to convert a delimited string into an object.<br />
    For example querystrings: "name_1=value_1&name_2=value_2" ==> {name_1:value_1,name_2:value_2};<br/><br />
    
    Note that property values could also contain the same sPropDelim and sValueDelim strings.  Proper string encoding should occur
    to not trip up the parsing of the string.  Said values may be ascii escaped, and in turn, along with the <i><b>bRecurse</b></i> constructor parameter set to true, will cause nested ParamHash objects to be created.
    
    @constructor
    @memberOf $sf.lib.lang
    @exports ParamHash as $sf.lib.lang.ParamHash
    @param {String} [sString]  The delimited string to be converted
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [bNoOverwrite=false]  If true, when a name is encountered more than 1 time in the string it will be ignored.
    @param {Boolean} [bRecurse=false]  If true, when a value of a property that is parsed also has both the sPropDelim and sValueDelim inside, convert that value to another ParamHash object automatically
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1");
    alert(ph.x); // == 1
    alert(ph.y); // == 1
    alert(ph.z); // == 1
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x:1;y:2;z:3", ";", ":");
    alert(ph.x); // == 1
    alert(ph.y); // == 2
    alert(ph.z); // == 3
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2");
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 2 b/c of 2 properties with the same name
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2",null,null,true); //null for sPropDelim and sValueDelim == use default values of "&" and "=" respectively
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 1 b/c bNoOverwrite was set to true
    
    @example
    //You can also do recursive processing if need be
    var points	= new $sf.lib.lang.ParamHash(),
    point_1	= new $sf.lib.lang.ParamHash(),
    point_2	= new $sf.lib.lang.ParamHash();
    
    point_1.x = 100;
    point_1.y = 75;
    
    point_2.x = 200;
    point_2.y = 150;
    
    points.point_1	= point_1;
    points.point_2	= point_2;
    
    var point_str	= points.toString();  // == "point_1=x%3D100%26y%3D75%26&point_2=x%3D200%26y%3D150%26&";
    var points_copy	= new $sf.lib.lang.ParamHash(point_str, null, null, true, true); //note passing true, b/c we want to recurse
    
    alert(points_copy.point_1.x) // == "100";
     */
    ParamHash = function(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse) {
      var added, cnt, doAdd, idx, idx2, idx3, io, len, len2, me, nm, nv, obj, pairs, sTemp, sTemp2, sTemp3, ss;
      me = this;
      io = "indexOf";
      ss = "substring";
      doAdd = false;
      if (!(me instanceof ParamHash)) {
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
      }
      if (!arguments.length) {
        return me;
      }
      if (sString && typeof sString === "object") {
        return mix(new ParamHash("", sPropDelim, sValueDelim, bNoOverwrite, bRecurse), sString);
      }
      sString = cstr(sString);
      sPropDelim = cstr(sPropDelim) || "&";
      sValueDelim = cstr(sValueDelim) || "=";
      if (!sString) {
        return me;
      }
      if (sPropDelim !== "?" && sValueDelim !== "?" && sString.charAt(0) === "?") {
        sString = sString[ss](1);
      }
      idx = sString[io]("?");
      idx2 = sString[io](sValueDelim);
      if (idx !== -1 && idx2 !== -1 && idx > idx2) {
        sTemp = _es(sString[ss](idx2 + 1));
        sTemp2 = sString.substr(0, idx2 + 1);
        sString = sTemp2 + sTemp;
      } else if (idx !== -1) {
        sString = sString[ss](idx + 1);
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite);
      }
      if (sString.charAt(0) === sPropDelim) {
        sString = sString[ss](1);
      }
      pairs = sString.split(sPropDelim);
      cnt = pairs.length;
      idx = 0;
      while (cnt--) {
        sTemp = pairs[idx++];
        added = false;
        doAdd = false;
        if (sTemp) {
          nv = sTemp.split(sValueDelim);
          len = nv.length;
          if (len > 2) {
            nm = _ue(nv[0]);
            nv.shift();
            if (bRecurse) {
              sTemp2 = nm + sValueDelim;
              idx2 = sString[io](sTemp2);
              len = sTemp2[LEN];
              sTemp3 = sString[ss](idx2 + len);
              sTemp2 = sPropDelim + sPropDelim;
              len2 = sTemp2[LEN];
              idx3 = sTemp3[io](sTemp2);
              if (idx3 !== -1) {
                sTemp3 = sString.substr(idx2 + len, idx3 + len2);
                obj = new ParamHash(sTemp3, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
                sTemp3 = "";
                len = 0;
                for (sTemp3 in obj) {
                  continue;
                }
                if (len > 0) {
                  idx += len - 1;
                }
                sTemp = obj;
              } else {
                sTemp = _ue(nv.join(sValueDelim));
              }
            } else {
              sTemp = _ue(nv.join(sValueDelim));
            }
            doAdd = true;
          } else if (len === 2) {
            nm = _ue(nv[0]);
            sTemp = _ue(nv[1]);
            doAdd = true;
          }
          if (doAdd) {
            if (bNoOverwrite) {
              if (!(nm in me)) {
                me[nm] = sTemp;
                added = true;
              }
            } else {
              me[nm] = sTemp;
              added = true;
            }
            if (bRecurse && added && nm && sTemp && typeof sTemp !== "object" && (sTemp[io](sPropDelim) >= 0 || sTemp[io](sValueDelim) >= 0)) {
              me[nm] = new ParamHash(sTemp, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
            }
          }
        }
      }
    };

    /*
    Converts a ParamHash object back into a string using the property and value delimiters specifed (defaults to "&" and "=").
    Again this method works recursively.  If an object is found as a property, it will convert that object into a ParamHash string
    and then escape it. Note also that this class's valueOf method is equal to this method.
    
    @methodOf ParamHash#
    @public
    @function
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [escapeProp=false] Whether or not to ascii escape the name of a property
    @param {Boolean} [dontEscapeValue=false] Do not escape values or properties automatically
    @return {String} the encoded string representation of the object.
     */
    toString = function(sPropDelim, sValueDelim, escapeProp, dontEscapeValue) {
      var buffer, item, itemType, me, prop;
      prop = void 0;
      buffer = [];
      me = this;
      itemType = void 0;
      item = void 0;
      sPropDelim = sPropDelim || "&";
      sValueDelim = sValueDelim || "=";
      for (prop in me) {
        item = me[prop];
        itemType = typeof item;
        if (item && itemType === "function") {
          continue;
        }
        if (item && itemType === "object") {
          item = toString.apply(item, [sPropDelim, sValueDelim, escapeProp, dontEscapeValue]);
        }
        if (escapeProp) {
          prop = _es(prop);
        }
        if (!dontEscapeValue) {
          item = _es(item);
        }
        buffer.push(prop, sValueDelim, item, sPropDelim);
      }
      return cstr(buffer);
    };
    proto = ParamHash.prototype;
    if (!String.prototype.trim) {
      String.prototype.trim = trim;
    }

    /*
    @ignore
     */
    proto.toString = proto.valueOf = toString;
    lang = {
      ParamHash: ParamHash,
      cstr: cstr,
      cnum: cnum,
      cbool: cbool,
      noop: noop,
      trim: trim,
      callable: callable,
      guid: guid,
      mix: mix,
      time: time,
      rand: rand,
      def: def,
      ns: ns,
      jssafe_html: jssafe_html,
      isArray: isArray
    };
    if (typeof exports !== "undefined" && exports !== null) {
      return exports.lang = lang;
    } else {
      return lang;
    }
  })(window);

}).call(this);

},{}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var logError, logInfo, win;
    win = window;

    /*
    Write an entry to the console log and fire any log listeners
    
    @message  The log message
     */
    logInfo = function(message) {
      if (win.console && console.log) {
        console.log(message);
      }
    };

    /*
    Write an entry to the console error log and fire any log listeners
    
    @message  The log message
     */
    logError = function(message) {
      if (win.console && console.error) {
        console.error(message);
      } else {
        if (win.console && console.log) {
          console.log(message);
        }
      }
    };
    return {
      info: logInfo,
      error: logError
    };
  })(window);

}).call(this);

},{}],9:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.once = noop;
process.off = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])